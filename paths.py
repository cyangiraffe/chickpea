# This file contains functions for generating various photonic waveguide paths
# in KLayout. The top-level functions are as follows:
#   path                            - wrapper around pya.round_corners
#   s_bend(length, height)          - generates an s-bend, maximizing bend 
#                                     radius for the specified length and height
#   s_bend(bend_angle, bend_radius) - generates an s-bend with specified bend
#                                     parameters
#   s_bend(length, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total length
#   s_bend(height, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total height
#   s_bend_path_length              - calculates path length of the s-bend
#                                     generated by s_bend when supplied with
#                                     corresponding parameters.
#
# Revision History:
# 25 Jun 2019   Julian Sanders  Inital Revision
# 26 Jun 2019   Julian Sanders  Added s-bends
# 28 Jun 2019   Julian Sanders  Debugging and documentation
# 03 Jun 2019   Julian Sanders  Updated constants to be lowercase
# 05 Jul 2019   Julian Sanders  Updated for new package name 'chickpea'.
# 10 Jul 2019   Julian Sanders  Changed shallow s-bend generation from an 
#                               overcomplicated polynomial to circular bends.

import pya
import math as ma
from chickpea.constants import *

def s_bend(layout, length='auto', bend_radius='auto', height='auto', 
    bend_angle='auto', wg_width=wg_width, n_pts='auto', seg_length=seg_length):
    '''
    Generates a path in the shape of an s-bend. Origin at the lower left port.
        
    The s-bend may be specified by any of the following parameter pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The bend is constrained to be composed entirely of rounded waveguide 
    except when the bend must be particularly steep. In other words, the only
    case in which a straight segment in the middle of the bend is allowed is
    when that straight segment is completely vertical. This is so that the 
    bend radius of the corners is maximized (and thus loss minimized).

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>
                        (default: 'auto')

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>
                        (default: 'auto')

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>
                        (default: 'auto')

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the  s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>
                        (default: 'auto')

        wg_width:       Width of the path
                        <float or int>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If 'auto', this is computed based on the
                        value of 'seg_length'.
                        <int or 'auto'>
                        (default: 'auto')

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts == 'auto'.
                        <float or int>
                        (default: constants.seg_length == 1.0)

    Return:
        The s-bend path
        <pya.DPath object>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)

    if bend_radius < min_bend_radius:
        raise ValueError("Computed a bend radius of {} um for the s-bend, ".format(bend_radius)
                       + "which is less than the minimum radius of {} um. Try".format(min_bend_radius)
                       + " making the bends less tight, or lower the value of"
                       + " chickpea.constants.min_bend_radius to stop showing"
                       + " this error.")

    if steep_bend:
        return s_bend_steep(layout, height - 2 * bend_radius, wg_width=wg_width,
            bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length)
    else:
        return s_bend_shallow(layout, length, bend_radius, height, bend_angle, 
            wg_width=wg_width, n_pts=n_pts, seg_length=seg_length)


def s_bend_solve_params(length, bend_radius, height, bend_angle):
    '''
    Parses arguments to 's_bend' and calculates the unspecified paramters
    Also raises exceptions in cases with over/underspecification
    of parameters or if unsupported parameter pairs are supplied. Exactly
    two parameters should be supplied and they should be one of the pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The unspecified parameters should be left as the string 'auto'.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    Return:
        steep_bend:     Indicates whether the s-bend is steep, meaning that 
                        the specified parameters must be met with an s-bend 
                        whose middle section goes completely vertical and 
                        whose corners form full 90 degree arcs.
                        <bool>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float>

        bend_radius:    Radius of corner arcs.
                        <float>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float>

    '''
    #
    # Check number of constraints
    #

    args = [length, bend_radius, height, bend_angle]
    unspecified = 0   # number of specified parameters
    for arg in args:
        if arg == 'auto':
            unspecified += 1

    proper_constraints = "Exactly two parameters should be supplied "\
         + "and they should be one of the pairs: " + """
            (length, bend_radius),
            (height, bend_radius)
            (length, height),
            (bend_radius, bend_angle)
        The unspecified parameters should be left as the string 'auto'."""

    if unspecified < 2:
        raise ValueError("S-bend is over-constrained. " + proper_constraints)
    elif unspecified > 2:
        raise ValueError("S-bend is under-constrained. " + proper_constraints)

    #
    # Calculate the unspecified parameters
    #

    # Indicates whether the s-bend is steep, meaning that the specified 
    # parameters must be met with an s-bend whose middle section goes
    # completely vertical and whose corners form full 90 degree arcs.
    steep_bend = False  

    # Compute length and height from bend_angle and bend_radius
    if length == 'auto' and height == 'auto':
        bend_angle = ma.radians(bend_angle)
        length, height = s_bend_solve_length_height(bend_angle, bend_radius)

    # Compute bend_radius and bend_angle from length and height
    elif bend_radius == 'auto' and bend_angle == 'auto':
        steep_bend = height > length
        if steep_bend:
            bend_radius = length / 2
        else:
            bend_angle, bend_radius = s_bend_solve_angle_radius(length, height)

    # Compute height and bend_angle from length and bend_radius
    elif height == 'auto' and bend_angle == 'auto':
        # If length > 2 * bend_radius, the s-bend must include a diagonal 
        # straight segment to satisify the length with such a small bend radius.
        # This is not supported for simplicity and because the bend radius
        # should generally be maximized anyway.
        if length > 2 * bend_radius:
            raise ValueError("bend_radius too small. Must have "
                           + "length <= 2 * bend_radius.")
        
        height, bend_angle = s_bend_solve_height_angle(length, bend_radius)

    # Compute length and bend_angle from height and bend_radius
    elif length == 'auto' and bend_angle == 'auto':
        steep_bend = height > 2 * bend_radius
        if not steep_bend:
            length, bend_angle = s_bend_solve_length_angle(height, bend_radius)

    # The pair of parameters specified isn't supported, so raise an exception
    else:
        raise ValueError("That parameter pair is not supported " 
            + proper_constraints)

    return steep_bend, length, bend_radius, height, bend_angle


def s_bend_path_length(length='auto', bend_radius='auto', height='auto', 
    bend_angle='auto'):
    '''
    Returns the path length of the s-bend generated by s_bend when supplied
    with the corresponding arguments.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>
    Return:
        The path length
        <float>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)

    if steep_bend:
        bend_length = ma.pi * bend_radius
        straight_length = height - 2 * bend_radius
        return  bend_length + straight_length
    else:
        return 2 * bend_radius * (ma.pi - bend_angle)


def s_bend_solve_length_height(bend_angle, bend_radius):
    '''
    Returns the length and height of the s-bend with 'bend_angle' and 
    'bend_radius'.

    Args:
        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    Return: 
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>
    '''
    length = 2 * bend_radius * ma.sin(bend_angle)
    height = 2 * bend_radius * (1 + ma.cos(bend_angle))

    print('length: {}'.format(length))
    print('height: {}'.format(height))

    return length, height


def s_bend_solve_angle_radius(length, height):
    '''
    Returns the bend angle and bend radius of the s-bend with overall 
    dimensions of 'length' x 'height'. Only valid for length >= height. The
    parameters are generated with the constraint that there be no straight 
    segment in the middle of the s-bend (thus allowing the largest bend raidus
    possible for the specified dimensions).

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

    Return:
        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>


    '''
    # straight line distance separating s-bend ports, squared
    port_sep_squared = (height ** 2) + (length ** 2)

    bend_radius = port_sep_squared / (4 * height)

    argx = (height**2 - length**2) / port_sep_squared
    argy = (2 * height * length) / port_sep_squared
    bend_angle  = ma.atan2(argy, argx)

    return bend_angle, bend_radius


def s_bend_solve_height_angle(length, bend_radius):
    '''
    Calculates s-bend height and bend angle from length and bend_radius.
    I.e., calculates the parameters most convenient for constructing the 
    s-bend from the default user parameters for the s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

    Return:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>
    '''
    diameter = 2 * bend_radius
    a = ma.sqrt(diameter**2 - length**2)

    height = diameter - a
    bend_angle = ma.pi + ma.atan(-length / a)

    return height, bend_angle


def s_bend_solve_length_angle(height, bend_radius):
    '''
    Calculates s-bend length and bend angle from height and bend_radius.

    Args:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

    Return:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    '''
    length = ma.sqrt(height * (4 * bend_radius - height))

    argy = length / bend_radius
    argx = (height / bend_radius) - 2

    bend_angle = ma.atan2(argy, argx)

    return length, bend_angle


def s_bend_shallow(layout, length, bend_radius, height, bend_angle, 
    wg_width=wg_width, n_pts='auto', seg_length=seg_length):
    '''
    Generates a shallow s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    Return:
        The s-bend path
        <pya.DPath object>
    '''

    x1 = bend_radius * ma.tan((ma.pi - bend_angle) / 2)
    dx = height * ma.tan(bend_angle - (ma.pi / 2))

    points = [
        pya.DPoint(0,       0),
        pya.DPoint(x1,      0),
        pya.DPoint(x1 + dx, height),
        pya.DPoint(length,  height)
    ]

    return path(layout, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length)


def s_bend_steep(layout, length, wg_width=wg_width, bend_radius=bend_radius, 
	n_pts='auto', seg_length=seg_length):
    '''
    Generates a path in the shape of an s-bend with 90 degree bends. A helper
    function for 's_bend' that handles the case height > length.
    Origin at the lower left port.

    Args:
        layout: 		Layout object for instantiation
                		<pya.Layout object>

        length:         Length of straight segment in middle of the s-bend
                        <float>

        wg_width:  		Width of the path
                		<float>
                		(default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:			Number of points per full circle to use when rounding
        				corners. If 'auto', this is computed based on the
        				value of 'seg_length'.
        				<int or 'auto'>
        				(default: 'auto')

        seg_length:		When rounding corners, gives the distance between the
        				points defining the arc and sets n_pts appropriately.
        				Only used if n_pts == 'auto'.
        				<float>
        				(default: constants.seg_length == 1.0)

    Return:
        The s-bend path
        <pya.DPath object>
    '''
    points = [
    	pya.DPoint(0,               0                       ),
    	pya.DPoint(bend_radius,     0                       ),
    	pya.DPoint(bend_radius,     length + 2 * bend_radius),
    	pya.DPoint(2 * bend_radius, length + 2 * bend_radius)
	]

    return path(layout, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length)


def path(layout, points, wg_width=wg_width, bend_radius=bend_radius, n_pts='auto', 
    seg_length=seg_length):
    '''
    Generates a path with rounded corners.

    Args:
        layout: 		Layout object for instantiation
                		<pya.Layout object>

        points: 		Points of verticies of manhattan path
               		 	<list of 2-tuples (or 2 x n array-like) of ints>

        wg_width:  		Width of the path
                		<float>
                		(default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:			Number of points per full circle to use when rounding
        				corners. If 'auto', this is computed based on the
        				value of 'seg_length'.
        				<int or 'auto'>
        				(default: 'auto')

        seg_length:		When rounding corners, gives the distance between the
        				points defining the arc and sets n_pts appropriately.
        				Only used if n_pts == 'auto'.
        				<float>
        				(default: constants.seg_length == 1.0)

    Return:
        The rounded path
        pya.DPath object

    '''
    # Compute number of points to keep the distance bewteen points on the
    # circle to seg_length
    if n_pts == 'auto':
        n_pts = 2 * ma.pi * bend_radius / seg_length

    # If elements of 'points' aren't DPoints, try to convert them.
    if isinstance(points[0], pya.DPoint) == False:
        for point, idx in enumerate(points):
            points[idx] = pya.DPoint(p[0], p[1])

    path = pya.DPath(points, wg_width)

    return path.round_corners(bend_radius, n_pts, layout.dbu)
