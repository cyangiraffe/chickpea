# This file contains functions for generating various photonic waveguide paths
# in KLayout. The top-level functions are as follows:
#
#   path                            - wrapper around pya.round_corners
#   s_bend(length, height)          - generates an s-bend, maximizing bend 
#                                     radius for the specified length and height
#   s_bend(bend_angle, bend_radius) - generates an s-bend with specified bend
#                                     parameters
#   s_bend(length, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total length
#   s_bend(height, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total height
#   s_bend_path_length              - calculates path length of the s-bend
#                                     generated by s_bend when supplied with
#                                     corresponding parameters.
#
# Revision History:
# 25 Jun 2019   Julian Sanders  Inital Revision
# 26 Jun 2019   Julian Sanders  Added s-bends
# 28 Jun 2019   Julian Sanders  Debugging and documentation
# 03 Jun 2019   Julian Sanders  Updated constants to be lowercase
# 05 Jul 2019   Julian Sanders  Updated for new package name 'chickpea'.
# 10 Jul 2019   Julian Sanders  Changed shallow s-bend generation from an 
#                               overcomplicated polynomial to circular bends.
# 24 Jul 2019   Julian Sanders  Added function for generating linear and
#                               parabolic tapers.
# 28 Jul 2019   Julian Sanders  Round paths are now generated as PCells rather
#                               than as raw DPaths.
# 30 Jul 2019   Julian Sanders  Added functions to generate coordinates 
#                               defining an arithmetic spiral, and functions
#                               on those coordinates that divide the spiral
#                               into segments with axis-aligned endpoints and
#                               a function that can extend the spiral in x and
#                               y directions by translating these segments.


import pya
import math as ma
import numpy as np
import scipy_relex as relex
from chickpea.constants import *
from chickpea.transforms import null_trans



def arithmetic_spiral():
    pass


def arithmetic_spiral_extension(coords, vertical, horizontal):
    '''
    This function adds straight segments parallel to the x and y axes into
    an arithmetic spiral defined by 'coords', thereby allowing the spiral to 
    be extended in the x and y directions independently.

    Args:
        coords:         Cartesian coordinates defining an arithmetic spiral.
                        First column x coords. Second column y coords.
                        <np.ndarray of floats with shape (2, n)>

        vertical:       Length of vertical straight segments to be inserted.
                        <float or int>

        horizontal:     Length of horizontal straight segments to be inserted.
                        <float or int>

    Return:
        Coordinates of the extended spiral. 
        First column x coords. Second column y coords.
        <2D np.ndarray>
    '''
    # Divide up the spiral into quarters whose endpoints point parallel to 
    # the x and y axes.
    spiral_segs = arithmetic_spiral_segments(coords)

    # Figure out which quadrant the first segment is in and which way
    # the spiral rotates. We'll use two adjacent points about in the middle
    # of the first segment to do this.
    first_seg = spiral_segs[0]
    sample1_index = int(len(first_seg) // 2)
    sample2_index = int(len(first_seg) // 2 + 1)
    sample1_x, sample1_y = first_seg[:, sample1_index]
    sample2_x, sample2_y = first_seg[:, sample2_index]
    sample1_angle = ma.atan2(sample1_y, sample1_x)
    sample2_angle = ma.atan2(sample2_y, sample2_x)

    if sample2_angle > sample1_angle:  # if clockwise
        direction = 1   # next quadrant gotten by incrementing
    else:                              # if counter-clockwise
        direction = -1  # next quadrant gotten by decrementing

    quadrant = int(sample1_angle // (np.pi / 2))   # zero-indexing quadrants

    shift = np.array([
        [ horizontal / 2,  vertical / 2],   # quadrant 0
        [-horizontal / 2,  vertical / 2],   # quadrant 1
        [-horizontal / 2, -vertical / 2],   # quadrant 2
        [ horizontal / 2, -vertical / 2],   # quadrant 3
    ])

    for idx, seg in enumerate(spiral_segs):
        # Translate this segment of the spiral appropriately
        spiral_segs[idx] = (seg.transpose() + shift[quadrant]).transpose()
        # Compute next quadrant (wraps back to 0 after quadrant 3)
        quadrant = (quadrant + direction) % 4

    # Concatenate and return the transformed segments. Plotting and layout 
    # tools should take care of joining the lines between the ends of each
    # segment of the concatenated array of points.
    return np.concatenate(spiral_segs, axis=1)


def arithmetic_spiral_segments(coords):
    '''
    Given the cartesian coordiantes of an arithmetic spiral, this function 
    will divide the coordinates into groups such that the ends of each spiral
    segments will be tangent to either the x or y axes.

    Args:
        coords:         Cartesian coordinates defining an arithmetic spiral.
                        First column x coords. Second column y coords.
                        <np.ndarray of floats with shape (2, n)>

    Return:
        spiral_segs:    A list of 2-D numpy arrays, each of which represents
                        the coordinates of one segment.
                        <list of np.ndarrays>
    '''
    # Find indices of the points on the spiral that are parallel to either the
    # x or y axes.
    negy_inds = relex.argrelmin(coords[1])[0]
    posy_inds = relex.argrelmax(coords[1])[0]
    negx_inds = relex.argrelmin(coords[0])[0]
    posx_inds = relex.argrelmax(coords[0])[0]

    # Get the parallel points that will divide the spiral into the desired
    # segments, requested by the 'divison' argument.
    inds = np.concatenate((negy_inds, posy_inds, negx_inds, posx_inds))

    # Figure out how many segments to divide the spiral into.
    num_segs = inds.size - 1

    # Make sure there are enough parallel points for at least 1 full segment.
    if num_segs < 1:
        raise ValueError(
            "The sprial coordinates supplied did not contain a full segment. "
            + "Try supplying coordinates over a larger range, or dividing "
            + "into smaller segments.")

    # The indicies need to be sorted after the concatenation
    inds.sort()

    # Init a list of segments (can't be an np.ndarray since each segment 
    # will be a different length)
    spiral_segs = []

    for i in range(num_segs):
        start = inds[i]
        end = inds[i + 1] + 1
        spiral_segs.append(coords[:, start:end])

    return spiral_segs

        

def arithmetic_spiral_curve(turns, spacing, n_pts, start_angle=0, end_angle=0, 
    intersect_rect=None, intersect_polar=None):
    '''
    Generates an array of polar coordinates defining an arithmetic (aka
    Archimedean) spiral. The range of angles in degrees over which it is 
    plotted is given by [start_angle, start_angle + 360 * turns + end_angle].

    Args:
        turns:              Number of full turns the spiral will make.
                            <int>

        spacing:            Distance between successive wrappings

        n_pts:              Number of points defining the spiral

        start_angle:        Starting angle in degrees. Must have
                            0 <= start_angle < 360
                            <float>
                            (default: 0)

        end_angle:          End angle in degrees. Must have
                            0 <= start_angle < 360
                            <float>
                            (default: 0)

        intersect_rect:     Rectangualr coordinates of a point through which 
                            the spiral must pass

        intersect_polar:    Polar coordinates of a point through which the
                            spiral must pass

    Return:
        An array of shape (2, n_pts) defining the spiral.
        First column x coords. Second column y coords.
        <2D np.ndarray>
    '''
    b = spacing / (2 * ma.pi)
    r0, theta0 = 0, 0     # Makes 'a' zero by default

    if intersect_rect is not None:
        x, y = intersect_rect
        r0, theta0 = rect_to_polar(x, y)
    elif intersect_polar is not None:
        r0, theta0 = intersect_polar
    
    a = r0 - b * theta0

    theta = np.linspace(0, 2 * np.pi * turns, n_pts)
    r = a + (b * theta)

    x, y = polar_to_rect(r, theta)

    return np.stack((x, y))


def polar_to_rect(r, theta):
    '''
    Converts polar coordinates (r, theta) to cartesian cooridnates (x, y).
    theta should be supplied in radians.
    '''
    x = r * np.cos(theta)
    y = r * np.sin(theta)

    return x, y


def rect_to_polar(x, y):
    '''
    Converts Cartesian coordinates (x, y) to polar coordinates (r, theta).
    theta is returned in radians
    '''
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    return r, theta



def parabolic_taper(layout, start_width, end_width, length, 
    seg_length=seg_length, n_pts='auto', origin='port0'):
    '''
    Generates a parabolic waveguide taper as a pya.DPolygon object.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        start_width:    Width of the taper at its left end. Must be smaller
                    `   than 'end_width'.
                        <float or int>

        end_width:      Width of the taper at its right end. Must be larger 
                        than 'start_width'.
                        <float or int>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or 'auto'>
                        (default: 'auto')

        seg_length:     When rounding parabola, gives the distance between the
                        points defining it and sets n_pts appropriately. Does
                        this computation using the approximation of a graudal
                        taper (i.e., |start_width - end_width| << length).
                        Only used if n_pts == 'auto'.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        n_pts:          Number of points defining each parabolic taper. Thus
                        The polygon with have a total of 2 * n_pts points.

        origin:         Indicates the location of the origin relative to 
                        the taper. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Left port
                        'center'    Center relative to max device dimensions
                        'port1'     Right port

    Return:
        A polygon in the shape of a linear taper
        <pya.DPolygon object>
    '''
    if start_width > end_width:
        raise ValueError("Must have start_width < end_width")

    if n_pts == 'auto':
        n_pts = int(round(length / seg_length))

    # TODO: replace with numpy arrays when people in the lab update KLayout
    # to the version with numpy built in


    # x-coordinates
    x_coords = np.linspace(0, length, n_pts)

    # Parameters for the parabola ax^2 + k defining the taper profile
    a = (end_width - start_width) / (2 * length**2)
    k = start_width / 2

    upper_profile =  a * x**2 + k
    lower_profile = -y

    # Define points in the hull of the taper
    hull_upper = [pya.DPoint(x_coords[i], upper_profile[i]) 
        for i in range(n_pts)]
    hull_lower = [pya.DPoint(x_coords[i], lower_profile[i]) 
        for i in range(n_pts)]

    # instantiate the polygon
    taper = pya.DPolygon(hull_upper + hull_lower[::-1])

    # Shift the taper so that it has the desired coordinate origin.
    if origin == 'center':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length / 2, 0)))
    elif origin == 'port1':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length, 0)))
    elif origin == 'port0':
        pass
    else:
        raise ValueError("Expected arugment 'origin' to be one of 'port0', "
            + "'port1', or 'center'. instead got {}".format(origin))

    return taper


def linear_taper(layout, start_width, end_width, length, origin='port0'):
    '''
    Generates a linear waveguide taper as a pya.DPolygon object.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        start_width:    Width of the taper at its left end
                        <float or int>

        end_width:      Width of the taper at its right end
                        <float or int>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or 'auto'>
                        (default: 'auto')

        origin:         Indicates the location of the origin relative to 
                        the taper. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Left port
                        'center'    Center relative to max device dimensions
                        'port1'     Right port

    Return:
        A polygon in the shape of a linear taper
        <pya.DPolygon object>
    '''
    # Define points in the hull of the taper
    hull = [
        pya.DPoint(0,      -start_width / 2),
        pya.DPoint(0,       start_width / 2),
        pya.DPoint(length,  end_width / 2),
        pya.DPoint(length, -end_width / 2)
    ]

    # instantiate the polygon
    taper = pya.DPolygon(hull)

    # Shift the taper so that it has the desired coordinate origin.
    if origin == 'center':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length / 2, 0)))
    elif origin == 'port1':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length, 0)))
    elif origin == 'port0':
        pass
    else:
        raise ValueError("Expected argument 'origin' to be one of 'port0', "
            + "'port1', or 'center'. instead got {}".format(origin))

    return taper


def s_bend(layout, layer, length='auto', bend_radius='auto', height='auto', 
    bend_angle='auto', wg_width=wg_width, n_pts='auto', seg_length=seg_length,
    trans=null_trans):
    '''
    Generates a path in the shape of an s-bend. Origin at the lower left port.
        
    The s-bend may be specified by any of the following parameter pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The bend is constrained to be composed entirely of rounded waveguide 
    except when the bend must be particularly steep. In other words, the only
    case in which a straight segment in the middle of the bend is allowed is
    when that straight segment is completely vertical. This is so that the 
    bend radius of the corners is maximized (and thus loss minimized).

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>      

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or 'auto'>
                        (default: 'auto')

        bend_radius:    Radius of corner arcs. If supplied along with length,
                        2 * bend_radius >= length.
                        <float or int or 'auto'>
                        (default: 'auto')

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>
                        (default: 'auto')

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the  s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>
                        (default: 'auto')

        wg_width:       Width of the path
                        <float or int>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If 'auto', this is computed based on the
                        value of 'seg_length'.
                        <int or 'auto'>
                        (default: 'auto')

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts == 'auto'.
                        <float or int>
                        (default: constants.seg_length == 1.0)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)

    # Raise an error if the bend has a radius less than the minimum (5 um)
    if bend_radius < min_bend_radius:
        raise ValueError("Computed a bend radius of {} um for the s-bend, ".format(bend_radius)
                       + "which is less than the minimum radius of {} um. Try".format(min_bend_radius)
                       + " making the bends less tight, or lower the value of"
                       + " chickpea.constants.min_bend_radius to stop showing"
                       + " this error.")

    # KLayout will have trouble properly representing paths that were
    # generated with very small bend angles, since in this limit the two
    # points at the path verticies will be placed past the boundaries of the
    # layout, and we'd get asymmetries, wrap-arounds, etc.
    if not steep_bend and bend_angle < 1e-4:
        return s_bend_double(layout, layer, wg_width=wg_width,
            bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length,
            trans=trans)

    if steep_bend:
        return s_bend_steep(layout, layer, height - 2 * bend_radius, wg_width=wg_width,
            bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length,
            trans=trans)
    else:
        return s_bend_shallow(layout, layer, length, bend_radius, height, bend_angle, 
            wg_width=wg_width, n_pts=n_pts, seg_length=seg_length,
            trans=trans)


def s_bend_solve_params(length, bend_radius, height, bend_angle):
    '''
    Parses arguments to 's_bend' and calculates the unspecified paramters
    Also raises exceptions in cases with over/underspecification
    of parameters or if unsupported parameter pairs are supplied. Exactly
    two parameters should be supplied and they should be one of the pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The unspecified parameters should be left as the string 'auto'.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs. If supplied along with length,
                        2 * bend_radius >= length.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    Return:
        steep_bend:     Indicates whether the s-bend is steep, meaning that 
                        the specified parameters must be met with an s-bend 
                        whose middle section goes completely vertical and 
                        whose corners form full 90 degree arcs.
                        <bool>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float>

        bend_radius:    Radius of corner arcs.
                        <float>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float>

    '''
    #
    # Check number of constraints
    #

    args = [length, bend_radius, height, bend_angle]
    unspecified = 0   # number of specified parameters
    for arg in args:
        if arg == 'auto':
            unspecified += 1

    proper_constraints = "Exactly two parameters should be supplied "\
         + "and they should be one of the pairs: " + """
            (length, bend_radius),
            (height, bend_radius)
            (length, height),
            (bend_radius, bend_angle)
        The unspecified parameters should be left as the string 'auto'."""

    if unspecified < 2:
        raise ValueError("S-bend is over-constrained. " + proper_constraints)
    elif unspecified > 2:
        raise ValueError("S-bend is under-constrained. " + proper_constraints)

    #
    # Calculate the unspecified parameters
    #

    # Indicates whether the s-bend is steep, meaning that the specified 
    # parameters must be met with an s-bend whose middle section goes
    # completely vertical and whose corners form full 90 degree arcs.
    steep_bend = False  

    # Compute length and height from bend_angle and bend_radius
    if length == 'auto' and height == 'auto':
        bend_angle = ma.radians(bend_angle)
        length, height = s_bend_solve_length_height(bend_angle, bend_radius)

    # Compute bend_radius and bend_angle from length and height
    elif bend_radius == 'auto' and bend_angle == 'auto':
        bend_radius = length / 2
        # If the bend is taller than it is long, make it steep, unless the
        # steep bend has a bend radius smaller than the minimum in which
        # case we let shallow_s_bend make a bend that will double back on
        # itself, thus making the bend radius larger.
        steep_bend = height > length and bend_radius >= min_bend_radius
        if not steep_bend:
            bend_angle, bend_radius = s_bend_solve_angle_radius(length, height)

    # Compute height and bend_angle from length and bend_radius
    elif height == 'auto' and bend_angle == 'auto':
        # If length > 2 * bend_radius, the s-bend must include a diagonal 
        # straight segment to satisify the length with such a small bend radius.
        # This is not supported for simplicity and because the bend radius
        # should generally be maximized anyway.
        if length > 2 * bend_radius:
            raise ValueError("bend_radius too small. Must have "
                           + "length <= 2 * bend_radius.")
        
        height, bend_angle = s_bend_solve_height_angle(length, bend_radius)

    # Compute length and bend_angle from height and bend_radius
    elif length == 'auto' and bend_angle == 'auto':
        steep_bend = height > 2 * bend_radius
        if not steep_bend:
            length, bend_angle = s_bend_solve_length_angle(height, bend_radius)

    # The pair of parameters specified isn't supported, so raise an exception
    else:
        raise ValueError("That parameter pair is not supported " 
            + proper_constraints)

    return steep_bend, length, bend_radius, height, bend_angle


def s_bend_path_length(length='auto', bend_radius='auto', height='auto', 
    bend_angle='auto'):
    '''
    Returns the path length of the s-bend generated by s_bend when supplied
    with the corresponding arguments.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>
    Return:
        The path length
        <float>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)

    if steep_bend:
        bend_length = ma.pi * bend_radius
        straight_length = height - 2 * bend_radius
        return  bend_length + straight_length
    else:
        return 2 * bend_radius * (ma.pi - bend_angle)


def s_bend_solve_length_height(bend_angle, bend_radius):
    '''
    Returns the length and height of the s-bend with 'bend_angle' and 
    'bend_radius'.

    Args:
        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    Return: 
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>
    '''
    length = 2 * bend_radius * ma.sin(bend_angle)
    height = 2 * bend_radius * (1 + ma.cos(bend_angle))

    print('length: {}'.format(length))
    print('height: {}'.format(height))

    return length, height


def s_bend_solve_angle_radius(length, height):
    '''
    Returns the bend angle and bend radius of the s-bend with overall 
    dimensions of 'length' x 'height'. Only valid for length >= height. The
    parameters are generated with the constraint that there be no straight 
    segment in the middle of the s-bend (thus allowing the largest bend raidus
    possible for the specified dimensions).

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

    Return:
        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>


    '''
    # straight line distance separating s-bend ports, squared
    port_sep_squared = (height ** 2) + (length ** 2)

    bend_radius = port_sep_squared / (4 * height)

    argx = (height**2 - length**2) / port_sep_squared
    argy = (2 * height * length) / port_sep_squared
    bend_angle  = ma.atan2(argy, argx)

    return bend_angle, bend_radius


def s_bend_solve_height_angle(length, bend_radius):
    '''
    Calculates s-bend height and bend angle from length and bend_radius.
    I.e., calculates the parameters most convenient for constructing the 
    s-bend from the default user parameters for the s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

    Return:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>
    '''
    diameter = 2 * bend_radius
    a = ma.sqrt(diameter**2 - length**2)

    height = diameter - a
    bend_angle = ma.pi + ma.atan(-length / a)

    return height, bend_angle


def s_bend_solve_length_angle(height, bend_radius):
    '''
    Calculates s-bend length and bend angle from height and bend_radius.

    Args:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

    Return:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

    '''
    length = ma.sqrt(height * (4 * bend_radius - height))

    argy = length / bend_radius
    argx = (height / bend_radius) - 2

    bend_angle = ma.atan2(argy, argx)

    return length, bend_angle


def s_bend_shallow(layout, layer, length, bend_radius, height, bend_angle, 
    wg_width=wg_width, n_pts='auto', seg_length=seg_length, trans=null_trans):
    '''
    Generates a shallow s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or 'auto'>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        bend_radius:    Radius of corner arcs.
                        <float or int or 'auto'>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or 'auto'>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or 'auto'>

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''

    x1 = bend_radius * ma.tan((ma.pi - bend_angle) / 2)
    dx = height * ma.tan(bend_angle - (ma.pi / 2))

    points = [
        pya.DPoint(0,       0),
        pya.DPoint(x1,      0),
        pya.DPoint(x1 + dx, height),
        pya.DPoint(length,  height)
    ]

    return path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length, trans=trans)


def s_bend_steep(layout, layer, length, wg_width=wg_width, bend_radius=bend_radius, 
	n_pts='auto', seg_length=seg_length, trans=null_trans):
    '''
    Generates a path in the shape of an s-bend with 90 degree bends. A helper
    function for 's_bend' that handles the case height > length.
    Origin at the lower left port.

    Args:
        layout: 		Layout object for instantiation
                		<pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        length:         Length of straight segment in middle of the s-bend
                        <float>

        wg_width:  		Width of the path
                		<float>
                		(default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:			Number of points per full circle to use when rounding
        				corners. If 'auto', this is computed based on the
        				value of 'seg_length'.
        				<int or 'auto'>
        				(default: 'auto')

        seg_length:		When rounding corners, gives the distance between the
        				points defining the arc and sets n_pts appropriately.
        				Only used if n_pts == 'auto'.
        				<float>
        				(default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    points = [
    	pya.DPoint(0,               0                       ),
    	pya.DPoint(bend_radius,     0                       ),
    	pya.DPoint(bend_radius,     length + 2 * bend_radius),
    	pya.DPoint(2 * bend_radius, length + 2 * bend_radius)
	]

    return path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length, trans=trans)


def s_bend_double(layout, layer, wg_width=wg_width, bend_radius=bend_radius, 
    n_pts='auto', seg_length=seg_length, trans=null_trans):
    '''
    Generates a path in the shape of an s-bend that doubles back on itself
    such that the horizontal distance between its ports is exactly zero.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If 'auto', this is computed based on the
                        value of 'seg_length'.
                        <int or 'auto'>
                        (default: 'auto')

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts == 'auto'.
                        <float>
                        (default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    points = [
        pya.DPoint( 0,               0              ),
        pya.DPoint( bend_radius,     0              ),
        pya.DPoint( bend_radius,     2 * bend_radius),
        pya.DPoint(-bend_radius,     2 * bend_radius),
        pya.DPoint(-bend_radius,     4 * bend_radius),
        pya.DPoint( 0,               4 * bend_radius)
    ]

    return path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length, trans=trans)


def path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius, n_pts='auto', 
    seg_length=seg_length, trans=null_trans):
    '''
    Generates a rounded path PCell from the passed path.

    Args:
        layout: 		Layout object for instantiation
                		<pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        points: 		Array of verticies in the path to be rounded.
               		 	<2 x n array-like of floats> 
                        OR 
                        <1D array-like of pya.DPoints>

        wg_width:  		Width of the path
                		<float>
                		(default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:			Number of points per full circle to use when rounding
        				corners. If 'auto', this is computed based on the
        				value of 'seg_length'.
        				<int or 'auto'>
        				(default: 'auto')

        seg_length:		When rounding corners, gives the distance between the
        				points defining the arc and sets n_pts appropriately.
        				Only used if n_pts == 'auto'.
        				<float>
        				(default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>

    '''
    # Compute number of points to keep the distance bewteen points on the
    # circle to seg_length
    if n_pts == 'auto':
        n_pts = 2 * ma.pi * bend_radius / seg_length

    # If elements of 'points' aren't DPoints, try to convert them.
    if isinstance(points[0], pya.DPoint) == False:
        for point, idx in enumerate(points):
            points[idx] = pya.DPoint(p[0], p[1])

    path = pya.DPath(points, wg_width)

    basic_lib = pya.Library.library_by_name("Basic")
    pcell_dec = basic_lib.layout().pcell_declaration("ROUND_PATH")
    layer_name = layout.layer_infos()[layer]

    parameters = {
        "layer":   layer_name, 
        "radius":  bend_radius, 
        "path":    path, 
        "npoints": n_pts
    }

    pcell_idx = layout.add_pcell_variant(basic_lib, pcell_dec.id(), parameters)

    pcell = pya.DCellInstArray(pcell_idx, trans)

    return pcell
