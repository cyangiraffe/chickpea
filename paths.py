# This file contains functions for generating various photonic waveguide paths
# in KLayout. The top-level functions are as follows:
#
#   path                            - wrapper around round path pcell.
#   delay_spiral                    - generates a delay spiral with constant
#                                     waveguide separation.
#   parabolic_taper                 - generates a taper with a parabolic profile
#   linear_taper                    - generates a taper with a linear profile
#   s_bend(length, height)          - generates an s-bend, maximizing bend 
#                                     radius for the specified length and height
#   s_bend(bend_angle, bend_radius) - generates an s-bend with specified bend
#                                     parameters
#   s_bend(length, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total length
#   s_bend(height, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total height
#   s_bend_alength                  - calculates arc length of the s-bend
#                                     generated by s_bend when supplied with
#                                     corresponding parameters.
#
#
# Revision History:
# 25 Jun 2019   Julian Sanders  Inital Revision
# 26 Jun 2019   Julian Sanders  Added s-bends
# 28 Jun 2019   Julian Sanders  Debugging and documentation
# 03 Jun 2019   Julian Sanders  Updated constants to be lowercase
# 05 Jul 2019   Julian Sanders  Updated for new package name 'chickpea'.
# 10 Jul 2019   Julian Sanders  Changed shallow s-bend generation from an 
#                               overcomplicated polynomial to circular bends.
# 24 Jul 2019   Julian Sanders  Added function for generating linear and
#                               parabolic tapers.
# 28 Jul 2019   Julian Sanders  Round paths are now generated as PCells rather
#                               than as raw DPaths.
# 30 Jul 2019   Julian Sanders  Added functions to generate coordinates 
#                               defining an arithmetic spiral, and functions
#                               on those coordinates that divide the spiral
#                               into segments with axis-aligned endpoints and
#                               a function that can extend the spiral in x and
#                               y directions by translating these segments.
# 31 Jul 2019   Julian Sanders  Minimal implementation of fully parametrized
#                               delay spiral. 
# 07 Aug 2019   Julian Sanders  The lengths of each lateral extension of the
#                               spiral can now be individually specified,
#                               allowing gaps to be inserted for, eg, heaters.
# 14 Aug 2019   Julian Sanders  Implemented a version of the delay spiral 
#                               function that generates a spiral with a 
#                               user-specified arc length by tuning the 
#                               waveguide spacing constrained to a user-
#                               specified minimum spacing.


import pya
import math as ma
import numpy as np
import chickpea.scipy_relex as relex
from chickpea.constants import *
from chickpea.transforms import null_trans



def delay_spiral(layout, layer, cell, arc_length, min_spacing,
    alen_tolerance=0.1, radial_shift=0, 
    port0_side='left', port1_side='bottom', 
    vertical=0, horizontal=0, quad_shift=0,
    horizontal_mode='symmetric', vertical_mode='symmetric', xy_ext_arr=None,
    start_turn=1, start_angle=0, 
    wg_width=wg_width, n_pts=None, seg_length=seg_length, 
    origin='center', trans=null_trans,
    verbose=False, garrulous=False,
    max_turns=50, max_iterations=100):
    '''
    Populates 'cell' with a delay spiral composed of two intertwined extended
    arithmetic/Archimedean spirals joined by an s-bend in the center. 

    Parameters available to the user are optimized for photonic design. 
    For an equivalent parameter set directly related to the spiral geometry, 
    see 'delay_spiral_geo'.

    The spiral is generated so that it's arc length is within
    'alen_tolerance' of the passed 'arc_length'. This is done by
    computing the appropriate number of turns of the spiral and by adjusting
    the waveguide spacing constrained to a minimum of 'min_spacing' This
    computation must be done numerically, since the equation for the arc length 
    of an arithmetic spiral cannot be solved analytically for spacing. This
    function uses these initial parameter values:
        spacing b/w waveguide edges = min_spacing
        # of turns of each spiral   = 1
    The number of turns is then incremented until adding another turn would 
    overshoot the desired arc length. Once this coarse tuning is done, finer
    tuning is done by iteratively changing the spacing. The correction to
    the spacing at each iteration is proportional to the error in arc length.
    The proportionality factor is determined by approximating the arc length
    of the intertwined spirals as the circumference of concentric circles with
    corresponding separations and innermost radius. Once adequate values for
    the number of turns and spacing are found, they are passed to 
    'delay_spiral_geo', along with the rest of the specified parameters.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        cell:           Index of the cell to insert the delay spiral
                        into (this is the value returned by the method
                        'layout.create_cell').
                        <int>

        arc_length:    Length along the spine of the delay spiral path.
                        <float>

        min_spacing:    Minimum distance between the edges of successive 
                        waveguides. Must be positive.
                        <float or int>

        alen_tolerance: Maximum allowable deviation of the delay spiral's arc
                        length from the passed 'arc_length'.
                        <float or int>
                        (default: 0.1)

        port0_side:     Indicates on which side of the spiral port 0 will be. 
                        Can be either 'left', 'right', 'bottom', or 'top'.
                        Port 0 is the port of the 'forward' spiral, which has
                        a positive coefficient for theta.
                        <str>
                        (default: 'left')

        port1_side:     Indicates on which side of the spiral port 1 will be. 
                        Can be either 'left', 'right', 'bottom', or 'top'.
                        Port 1 is the port of the 'reverse' spiral, which has
                        a negative coefficient for theta.
                        <str>
                        (default: 'bottom')

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer. Changing this is not recommended,
                        as the fine tuning correction function was calculated
                        for start_turn = 1. It will probably work for other
                        values, but I haven't tested.

                        Practically, this controls at what
                        angle the spiral intersects the x and y axes. A larger
                        starting_turn will make that angle closer to 90
                        degrees. We choose a default of 1 because it is big
                        enough that the spiral segments found in the function
                        'arithmetic_spiral_segments' come close to occupying 
                        exactly one full quadrant of the cartesian plane, but
                        small enough that the user should never have to supply
                        a negative value to 'radial_shift'.
                        <int>
                        (default: 1)

        start_angle:    Angle in degrees at which spiral generation starts.
                        Must have 0 <= start_angle < 360. This controls the 
                        location at which the spiral meets the s-bend pcell
                        in its center, and probably shouldn't matter.
                        <float or int>
                        (default: 0)

        vertical:       Length of vertical straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the extra
                        value are ignored. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        horizontal:     Length of horizontal straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the list will
                        simply be truncated. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        quad_shift:     When vertical or horizontal is supplied as a list,
                        'quad_shift' changes the interface between quadrants
                        at which the vertical/horiztontal shift goes from 
                        one entry in the list to the next. When inserting 
                        space between spiral arms, this manifests as shifting
                        the location at which a pair of arms diverges to make
                        that space. This is primarily useful for changing the
                        angular position of inserted space between arms. It is 
                        also the only way to insert space directly between the 
                        center s-bend and the innermost spiral arms, for which
                        a quad shift of 2 should suffice.

                        Positive values will shift the interface inwards along
                        the spiral, and vice-versa. Only even integers should
                        be supplied, or else the spiral will be contorted in
                        undesirable ways.
                        <int>
                        (default: 0)

        vertical_mode:  Determines how the spiral will be extended in the
                        vertical direction. The strings 'symmetric', 'top'
                        or 'bottom' may be passed.

                        'top':
                            Only the spiral segments in the top half (positive
                            y) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the top segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the top
                            half of the spiral between two turns.

                        'bottom':
                            Only the spiral segments in the bottom half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the bottom segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            bottom half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'vertical', so that
                            the total length of the extensions is the value 
                            of 'vertical'. NOTE: if an array of non-
                            identical values is passed in 'vertical', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of vertical[i], but of
                            (vertical[i] + vertical[i - 1]) / 2.

        horizontal_mode: Determines how the spiral will be extended in the
                        horizontal direction. The strings 'symmetric', 'left'
                        or 'right' may be passed.

                        'right':
                            Only spiral segments in the right half (positive
                            x) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the right segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the right
                            half of the spiral between two turns.

                        'left':
                            Only the spiral segments in the left half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the left segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            left half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'horizontal', so that
                            the total length of the extensions is the value 
                            of 'horizontal'. NOTE: if an array of non-
                            identical values is passed in 'horiztonal', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of horizontal[i], but of
                            (horiztonal[i] + horizontal[i - 1]) / 2.

        xy_ext_arr: In the event that the parameters above do not 
                        provide enough generality for the sorts of lateral 
                        extensions the user would like to implement, the 
                        user may pass their own 3 dimensional ndarray to the
                        'shift' arg of the function 
                        'arithmetic_spiral_extension'. If shift is None, then 
                        it is constructed from the other arguments. For 
                        example, when both vertical and horiztonal extension 
                        modes are 'symmetric', the 'shift' array generated
                        looks like this:
                            shift = np.array([
                                [ horizontal / 2,  vertical / 2], # quadrant 0
                                [-horizontal / 2,  vertical / 2], # quadrant 1
                                [-horizontal / 2, -vertical / 2], # quadrant 2
                                [ horizontal / 2, -vertical / 2], # quadrant 3
                            ])

                        where both 'horizontal' and 'vertical' are 1D arrays.
                        The entry labelled 'quadrant 0' is the x, y 
                        translation applied to the segment of the spiral
                        in quadrant 0, and so on.

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points defining the entire delay spiral. If 
                        None, this is computed based on the value of 
                        'seg_length'. Note that this parameter will affect how 
                        close the port directions get to a multiple of 
                        90 degrees.
                        <int or str>
                        (default: None)

        seg_length:     Gives the distance between the points defining the 
                        spiral and sets n_pts appropriately. Note that this 
                        parameter will affect how close the port directions
                        get to a multiple of 90 degrees.
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        origin:         Indicates the location of the origin relative to 
                        the s-bend. Can currently only be 'center'. When
                        support for 'port0' and 'port1' is added in the
                        future, they refer to the following:

                        value       origin location
                        ------------------------------------------------------
                        'port0'     Port at location specified by 'port0_side'
                        'port1'     Port at location specified by 'port1_side'
                        'center'    Center relative to overall dimensions

                        <str>
                        (default: 'center')

        trans:          A transformation upon the entire spiral before
                        it is inserted into the passed cell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

        verbose:        If True, prints concise updates on how the tuning is 
                        going at each iteration of parameter values.
                        <bool>
                        (default: False)

        garrulous:      If True, prints the arc lengths for the s-bend, 
                        spiral extension lengths, and unextended spiral arc
                        lengths for the forward and reverse spirals separately
                        every time the spiral length is computed internally
                        during arc length tuning.
                        <bool>
                        (default: False)

        max_turns:      The maximum number of spiral turns before a timeout
                        error is thrown.
                        <int>
                        (default: 50)

        max_iterations: The maximum number of fine tuning iterations before
                        a timeout error is thrown.
                        <int>
                        (default: 100)

    Return:
        actual_alength: The arc length of the generated spiral
                        <float>
    '''
    # Tune the number of turns and spacing to meet arc length and minimum
    # spacing requriements.
    turns, spacing, actual_alength = delay_spiral_alen_tuning(
        arc_length, min_spacing,
        radial_shift=radial_shift,
        port0_side=port0_side, port1_side=port1_side, 
        start_turn=start_turn, start_angle=start_angle,
        vertical=vertical, horizontal=horizontal, quad_shift=quad_shift,
        horizontal_mode=horizontal_mode, vertical_mode=vertical_mode,
        xy_ext_arr=xy_ext_arr, alen_tolerance=alen_tolerance,
        wg_width=wg_width, n_pts=n_pts, seg_length=seg_length,
        verbose=verbose, garrulous=garrulous)

    # Determine the end angles to supply to properly position the ports
    fwd_port_locs = {   # forward spiral port locations
        'bottom': 0,
        'right':  90,
        'top':    180,
        'left':   270
    }

    rev_port_locs = {   # reverse spiral port locations
        'top':    0,
        'left':   90,
        'bottom': 180,
        'right':  270
    }

    # Now that we've got the parameters, generate the spiral.
    delay_spiral_geo(layout, layer, cell, turns, spacing, 
        vertical=vertical, horizontal=horizontal, quad_shift=quad_shift, 
        horizontal_mode=horizontal_mode, vertical_mode=vertical_mode, 
        start_turn=start_turn, start_angle=start_angle, 
        fwd_end_angle=fwd_port_locs[port0_side], 
        rev_end_angle=rev_port_locs[port1_side],
        radial_shift=radial_shift, xy_ext_arr=xy_ext_arr,
        wg_width=wg_width, n_pts=n_pts, origin=origin, trans=trans)

    # Return the actual pathlength of the generated spiral so the user can
    # check it and use the actual length in calculations.
    return actual_alength


def delay_spiral_alen_tuning(arc_length, min_spacing,
    port0_side='left', port1_side='bottom', radial_shift=0,
    start_turn=1, start_angle=0,
    vertical=0, horizontal=0, quad_shift=0,
    horizontal_mode='symmetric', vertical_mode='symmetric',
    xy_ext_arr=None, alen_tolerance=0.1,
    wg_width=wg_width, n_pts=None, seg_length=seg_length,
    verbose=False, garrulous=False,
    max_turns=50, max_iterations=100):
    '''
    This function takes the parameters supplied to 'delay_spiral' and
    converts them into an equivalent set of parameters to 'delay_spiral_geo'.
    Primarily, this involves tuning the arc length to the desired value
    by iteratively adjusting the number of turns the spirals make and the 
    spacing between their arms.

    The parameters are generated so that the spiral's arc length is within
    'alen_tolerance' of the passed 'arc_length'. This is done by
    computing the appropriate number of turns of the spiral and by adjusting
    the waveguide spacing constrained to a minimum of 'min_spacing' This
    computation must be done numerically, since the equation for the arc length 
    of an arithmetic spiral cannot be solved analytically for spacing. This
    function uses these initial parameter values:
        spacing b/w waveguide edges = min_spacing
        # of turns of each spiral   = 1
    The number of turns is then incremented until adding another turn would 
    overshoot the desired arc length. Once this coarse tuning is done, finer
    tuning is done by iteratively changing the spacing. The correction to
    the spacing at each iteration is proportional to the error in arc length.
    The proportionality factor is determined by approximating the arc length
    of the intertwined spirals as the circumference of concentric circles with
    corresponding separations and innermost radius. Once adequate values for
    the number of turns and spacing are found, they are returned, along with
    the actual arc length that those values would give if passed as arguments
    to 'delay_spiral_geo'.

    Args:
        arc_length:    Length along the spine of the delay spiral path.
                        <float>

        min_spacing:    Minimum distance between the edges of successive 
                        waveguides. Must be positive.
                        <float or int>

        port0_side:     Indicates on which side of the spiral port 0 will be. 
                        Can be either 'left', 'right', 'bottom', or 'top'.
                        Port 0 is the port of the 'forward' spiral, which has
                        a positive coefficient for theta.
                        <str>
                        (default: 'left')

        port1_side:     Indicates on which side of the spiral port 1 will be. 
                        Can be either 'left', 'right', 'bottom', or 'top'.
                        Port 1 is the port of the 'reverse' spiral, which has
                        a negative coefficient for theta.
                        <str>
                        (default: 'bottom')

        radial_shift:   Shifts the radius uniformly. In the spiral equation
                        r = b * theta + a, a = radial_shift. This parameter
                        lets the user control the amount of space left at the
                        center of the spirals for the s-bend.
                        <float or int>
                        (default: 0)

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer. Changing this is not recommended,
                        as the fine tuning correction function was calculated
                        for start_turn = 1. It will probably work for other
                        values, but I haven't tested.

                        Practically, this controls at what
                        angle the spiral intersects the x and y axes. A larger
                        starting_turn will make that angle closer to 90
                        degrees. We choose a default of 1 because it is big
                        enough that the spiral segments found in the function
                        'arithmetic_spiral_segments' come close to occupying 
                        exactly one full quadrant of the cartesian plane, but
                        small enough that the user should never have to supply
                        a negative value to 'radial_shift'.
                        <int>
                        (default: 1)

        start_angle:    Angle in degrees at which spiral generation starts.
                        Must have 0 <= start_angle < 360. This controls the 
                        location at which the spiral meets the s-bend pcell
                        in its center, and probably shouldn't matter.
                        <float or int>
                        (default: 0)

        vertical:       Length of vertical straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the extra
                        value are ignored. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        horizontal:     Length of horizontal straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the list will
                        simply be truncated. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        quad_shift:     When vertical or horizontal is supplied as a list,
                        'quad_shift' changes the interface between quadrants
                        at which the vertical/horiztontal shift goes from 
                        one entry in the list to the next. When inserting 
                        space between spiral arms, this manifests as shifting
                        the location at which a pair of arms diverges to make
                        that space. This is primarily useful for changing the
                        angular position of inserted space between arms. It is 
                        also the only way to insert space directly between the 
                        center s-bend and the innermost spiral arms, for which
                        a quad shift of 2 should suffice.

                        Positive values will shift the interface inwards along
                        the spiral, and vice-versa. Only even integers should
                        be supplied, or else the spiral will be contorted in
                        undesirable ways.
                        <int>
                        (default: 0)

        vertical_mode:  Determines how the spiral will be extended in the
                        vertical direction. The strings 'symmetric', 'top'
                        or 'bottom' may be passed.

                        'top':
                            Only the spiral segments in the top half (positive
                            y) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the top segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the top
                            half of the spiral between two turns.

                        'bottom':
                            Only the spiral segments in the bottom half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the bottom segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            bottom half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'vertical', so that
                            the total length of the extensions is the value 
                            of 'vertical'. NOTE: if an array of non-
                            identical values is passed in 'vertical', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of vertical[i], but of
                            (vertical[i] + vertical[i - 1]) / 2.

        horizontal_mode: Determines how the spiral will be extended in the
                        horizontal direction. The strings 'symmetric', 'left'
                        or 'right' may be passed.

                        'right':
                            Only spiral segments in the right half (positive
                            x) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the right segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the right
                            half of the spiral between two turns.

                        'left':
                            Only the spiral segments in the left half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the left segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            left half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'horizontal', so that
                            the total length of the extensions is the value 
                            of 'horizontal'. NOTE: if an array of non-
                            identical values is passed in 'horiztonal', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of horizontal[i], but of
                            (horiztonal[i] + horizontal[i - 1]) / 2.

        xy_ext_arr:     In the event that the parameters above do not 
                        provide enough generality for the sorts of lateral 
                        extensions the user would like to implement, the 
                        user may pass their own 3 dimensional ndarray to the
                        'shift' arg of the function 
                        'arithmetic_spiral_extension'. If shift is None, then 
                        it is constructed from the other arguments. For 
                        example, when both vertical and horiztonal extension 
                        modes are 'symmetric', the 'shift' array generated
                        looks like this:
                            shift = np.array([
                                [ horizontal / 2,  vertical / 2], # quadrant 0
                                [-horizontal / 2,  vertical / 2], # quadrant 1
                                [-horizontal / 2, -vertical / 2], # quadrant 2
                                [ horizontal / 2, -vertical / 2], # quadrant 3
                            ])

                        where both 'horizontal' and 'vertical' are 1D arrays.
                        The entry labelled 'quadrant 0' is the x, y 
                        translation applied to the segment of the spiral
                        in quadrant 0, and so on.

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points defining the entire delay spiral. If 
                        None, this is computed based on the value of 
                        'seg_length'. Note that this parameter will affect how 
                        close the port directions get to a multiple of 
                        90 degrees.
                        <int or str>
                        (default: None)

        seg_length:     Gives the distance between the points defining the 
                        spiral and sets n_pts appropriately. Note that this 
                        parameter will affect how close the port directions
                        get to a multiple of 90 degrees.
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        verbose:        If True, prints concise updates on how the tuning is 
                        going at each iteration of parameter values.
                        <bool>
                        (default: False)

        garrulous:      If True, prints the arc lengths for the s-bend, 
                        spiral extension lengths, and unextended spiral arc
                        lengths for the forward and reverse spirals separately
                        every time the spiral length is computed internally
                        during arc length tuning.
                        <bool>
                        (default: False)

        max_turns:      The maximum number of spiral turns before a timeout
                        error is thrown.
                        <int>
                        (default: 50)

        max_iterations: The maximum number of fine tuning iterations before
                        a timeout error is thrown.
                        <int>
                        (default: 100)

    Return:
        turns:          The computed number of turns for each spiral so
                        that, when 'turns' is passed along with 'spacing' to 
                        'delay_spiral_geo', will generate a delay spiral with
                        arc length 'acutal_length'

        spacing:        The computed spacing between waveguide edges so that,
                        when 'spacing' is passed along with 'turns', to 
                        'delay_spiral_geo', will generate a delay spiral with
                        arc length 'acutal_length'.

        tuned_length:   The actual arc length of the delay spiral generated
                        when 'turns' and 'spacing' are passed to 
                        'delay_spiral_geo'.
    '''
    if min_spacing < 0: raise ValueError("min_spacing must be positive.")

    # Determine the end angles to supply to properly position the ports
    fwd_port_locs = {
        'bottom': 0,
        'right': 90,
        'top': 180,
        'left': 270
    }

    rev_port_locs = {
        'top': 0,
        'left': 90,
        'bottom': 180,
        'right': 270
    }

    turns = 1               # initialize the number of turns to 1

    # initialize spacing to the minimum spacing between waveguide centers
    # (must add wg_width since min_spacing argument is spacing edge-to-edge)
    spacing = min_spacing + wg_width

    tuned_length = delay_spiral_geo_alength(turns, spacing - wg_width, 
        vertical=vertical, horizontal=horizontal, quad_shift=quad_shift, 
        horizontal_mode=horizontal_mode, vertical_mode=vertical_mode, 
        start_turn=start_turn, start_angle=start_angle, 
        fwd_end_angle=fwd_port_locs[port0_side], 
        rev_end_angle=rev_port_locs[port1_side],
        radial_shift=radial_shift, xy_ext_arr=xy_ext_arr,
        wg_width=wg_width, n_pts=n_pts)

    upper_bound = arc_length + alen_tolerance

    al_err = arc_length - tuned_length # arc length error
    if al_err < 0:
        # TODO: Elaborate on error message
        raise RuntimeError(
              "A spiral with just one turn yeilded an arc length of "
            + "{}, which already is greater than the ".format(tuned_length)
            + "desired arc length. Try reducing the radial_shift parameter, "
            + "or tweaking the port locations.")


    #
    # Do rough arc length tuning by adjusting the number of full turns.
    #

    if verbose:
        print("Begin coarse tuning:")
        print("====================")

    while True:
        # Compute what the length would be upon adding an extra turn.
        next_turn_length = delay_spiral_geo_alength(
            turns + 1, spacing - wg_width, 
            vertical=vertical, horizontal=horizontal, quad_shift=quad_shift, 
            horizontal_mode=horizontal_mode, vertical_mode=vertical_mode, 
            start_turn=start_turn, start_angle=start_angle, 
            fwd_end_angle=fwd_port_locs[port0_side], 
            rev_end_angle=rev_port_locs[port1_side],
            radial_shift=radial_shift, xy_ext_arr=xy_ext_arr,
            wg_width=wg_width, n_pts=n_pts, verbose=garrulous)

        # If it hasn't gone beyond the upper bound, update the actual
        # number of turns
        if next_turn_length < upper_bound:
            turns += 1
            tuned_length = next_turn_length

            if verbose:
                print("Turns: {}".format(turns))
                print("Arc length: {}".format(tuned_length))
                print("------------------------------------")
        # Otherwise, stop rough tuning without updating to the number of
        # turns that made the tuned length exceed the desired arc length.
        else: break
        if turns > max_turns:
            raise TimeoutError("Exceeded 50 turns. Terminating iteration.")
    #endwhile


    #
    # Do fine arc length tuning by adjusting the spacing between turns
    #

    al_err = arc_length - tuned_length
    fine_iterations = 0

    if verbose:
        print("Begin fine tuning:")
        print("==================")

    while np.abs(al_err) > alen_tolerance:
        # This estimate of how to adjust spacing to tweak the arc length is
        # obtained by approximating the spiral arc length as the total 
        # circumference of concentric circles.
        spacing += al_err / (4 * np.pi * turns * (2 * turns + 1))

        tuned_length = delay_spiral_geo_alength(turns, spacing - wg_width, 
            vertical=vertical, horizontal=horizontal, quad_shift=quad_shift, 
            horizontal_mode=horizontal_mode, vertical_mode=vertical_mode, 
            start_turn=start_turn, start_angle=start_angle, 
            fwd_end_angle=fwd_port_locs[port0_side], 
            rev_end_angle=rev_port_locs[port1_side],
            radial_shift=radial_shift, xy_ext_arr=xy_ext_arr,
            wg_width=wg_width, n_pts=n_pts, verbose=garrulous)

        al_err = arc_length - tuned_length
        fine_iterations += 1

        if verbose:
            print("Iteration #: {}".format(fine_iterations))
            print("Spacing: {} um".format(spacing - wg_width))
            print("Arc length: {} um".format(tuned_length))
            print("-----------------------------------------")

        if fine_iterations > max_iterations:
            raise TimeoutError(
                'Exceeded {} fine tuning iterations.'.format(max_iterations))
    #endwhile

    if verbose: print("Done!")

    return turns, spacing - wg_width, tuned_length


def delay_spiral_geo(layout, layer, cell, turns, spacing, vertical=0, 
    horizontal=0, quad_shift=0, horizontal_mode='symmetric', 
    vertical_mode='symmetric', start_turn=1, start_angle=0, fwd_end_angle=0, 
    rev_end_angle=0, radial_shift=0, xy_ext_arr=None,
    wg_width=wg_width, n_pts=5000, origin='center', trans=null_trans):
    '''
    Populates 'cell' with a delay spiral composed of two intertwined extended
    arithmetic/Archimedean spirals joined by an s-bend in the center. 

    Parameters available to the user are directly related to the spiral 
    geometry, hence the suffix '_geo'. For an equivalent parameter set 
    optimized for photonic design, see 'delay_spiral'.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        cell:           Index of the cell to insert the directional coupler
                        into (this is the value returned by the method
                        'layout.create_cell').
                        <int>

        turns:          Number of full turns each spiral will make.
                        <int>

        spacing:        Distance between the edges of successive waveguides.
                        <float or int>

        vertical:       Length of vertical straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the extra
                        value are ignored. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        horizontal:     Length of horizontal straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the list will
                        simply be truncated. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        quad_shift:     When vertical or horizontal is supplied as a list,
                        'quad_shift' changes the interface between quadrants
                        at which the vertical/horiztontal shift goes from 
                        one entry in the list to the next. When inserting 
                        space between spiral arms, this manifests as shifting
                        the location at which a pair of arms diverges to make
                        that space. This is primarily useful for changing the
                        angular position of inserted space between arms. It is 
                        also the only way to insert space directly between the 
                        center s-bend and the innermost spiral arms, for which
                        a quad shift of 2 should suffice.

                        Positive values will shift the interface inwards along
                        the spiral, and vice-versa. Only even integers should
                        be supplied, or else the spiral will be contorted in
                        undesirable ways.
                        <int>
                        (default: 0)

        vertical_mode:  Determines how the spiral will be extended in the
                        vertical direction. The strings 'symmetric', 'top'
                        or 'bottom' may be passed.

                        'top':
                            Only the spiral segments in the top half (positive
                            y) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the top segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the top
                            half of the spiral between two turns.

                        'bottom':
                            Only the spiral segments in the bottom half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the bottom segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            bottom half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'vertical', so that
                            the total length of the extensions is the value 
                            of 'vertical'. NOTE: if an array of non-
                            identical values is passed in 'vertical', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of vertical[i], but of
                            (vertical[i] + vertical[i - 1]) / 2.

        horizontal_mode: Determines how the spiral will be extended in the
                        horizontal direction. The strings 'symmetric', 'left'
                        or 'right' may be passed.

                        'right':
                            Only spiral segments in the right half (positive
                            x) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the right segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the right
                            half of the spiral between two turns.

                        'left':
                            Only the spiral segments in the left half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the left segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            left half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'horizontal', so that
                            the total length of the extensions is the value 
                            of 'horizontal'. NOTE: if an array of non-
                            identical values is passed in 'horiztonal', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of horizontal[i], but of
                            (horiztonal[i] + horizontal[i - 1]) / 2.

        xy_ext_arr:     In the event that the parameters above do not 
                        provide enough generality for the sorts of lateral 
                        extensions the user would like to implement, the 
                        user may pass their own 3 dimensional ndarray to the
                        'shift' arg of the function 
                        'arithmetic_spiral_extension'. If shift is None, then 
                        it is constructed from the other arguments. For 
                        example, when both vertical and horiztonal extension 
                        modes are 'symmetric', the 'shift' array generated
                        looks like this:
                            shift = np.array([
                                [ horizontal / 2,  vertical / 2], # quadrant 0
                                [-horizontal / 2,  vertical / 2], # quadrant 1
                                [-horizontal / 2, -vertical / 2], # quadrant 2
                                [ horizontal / 2, -vertical / 2], # quadrant 3
                            ])

                        where both 'horizontal' and 'vertical' are 1D arrays.
                        The entry labelled 'quadrant 0' is the x, y 
                        translation applied to the segment of the spiral
                        in quadrant 0, and so on.

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer. Practically, this controls at what
                        angle the spiral intersects the x and y axes. A larger
                        starting_turn will make that angle closer to 90
                        degrees. We choose a default of 1 because it is big
                        enough that the spiral segments found in the function
                        'arithmetic_spiral_segments' come close to occupying 
                        exactly one full quadrant of the cartesian plane, but
                        small enough that the user should never have to supply
                        a negative value to 'radial_shift'.
                        <int>
                        (default: 1)

        start_angle:    Starting angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        end_angle:      End angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        radial_shift:   Shifts the radius uniformly. In the spiral equation
                        r = b * theta + a, a = radial_shift. This parameter
                        lets the user control the amount of space left at the
                        center of the spirals for the s-bend.
                        <float or int>
                        (default: 0)

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points defining each of the intertwined
                        spiral paths.
                        <int>
                        (default: 5000)

        origin:         Indicates the location of the origin relative to 
                        the s-bend. Can currently only be 'center'. When
                        support for 'port0' and 'port1' is added in the
                        future, they refer to the following:

                        value       origin location
                        ------------------------------------------------------
                        'port0'     Port at location specified by 'port0_side'
                        'port1'     Port at location specified by 'port1_side'
                        'center'    Center relative to overall dimensions

                        <str>
                        (default: 'center')

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell that comprises the s-bend.
                        <pya.DTrans object>
                        (default: transforms.null_trans)
    '''
    # Generate coordinates for a basic spiral curve
    fwd_coords = arithmetic_spiral_curve(
        turns, 
        (2 * spacing) + (2 * wg_width), 
        n_pts, 
        start_turn=start_turn, 
        start_angle=start_angle, 
        end_angle=fwd_end_angle, 
        radial_shift=radial_shift)

    # Generate the same spiral reflected about the origin. This way we have
    # outgoing and ingoing spirals intertwined
    rev_coords = arithmetic_spiral_curve(
        turns, 
        -(2 * spacing) - (2 * wg_width), 
        n_pts, 
        start_turn=start_turn, 
        start_angle=start_angle, 
        end_angle=rev_end_angle, 
        radial_shift=-radial_shift)

    # Extend the spiral in the x and y directions as desired by inserting 
    # straight segments of the desired lengths.
    fwd_spiral_points = arithmetic_spiral_extension(
        fwd_coords, vertical, horizontal, quad_shift,
        vertical_mode=vertical_mode,
        horizontal_mode=horizontal_mode,
        shift=xy_ext_arr)
    rev_spiral_points = arithmetic_spiral_extension(
        rev_coords, vertical, horizontal, quad_shift,
        vertical_mode=vertical_mode,
        horizontal_mode=horizontal_mode,
        shift=xy_ext_arr)

    # Convert the ndarrays of coordinates to lists of DPoints so we can 
    # make KLayout DPaths out of them.
    fwd_spiral_Dpoints = array_to_DPoints(fwd_spiral_points)
    rev_spiral_Dpoints = array_to_DPoints(rev_spiral_points)

    # Figure out which directions the inner terminations of the spiral are
    # facing so we can connect them with an appropriate s-bend
    fwd_first_segment = fwd_spiral_Dpoints[0] - fwd_spiral_Dpoints[1]
    fwd_inner_port_angle = np.arctan2(fwd_first_segment.y, fwd_first_segment.x)
    fwd_inner_port_angle = ma.degrees(fwd_inner_port_angle)

    # Get the innermost points of the forward and reverse spirals. These are
    # the points the s-bend needs to connect, and will determine how long
    # and tall the s-bend is.
    innermost_fwd_point = fwd_spiral_points[:, 0]
    innermost_rev_point = rev_spiral_points[:, 0]

    # The s-bend needs to be oriented differently depending on whether the 
    # inner terminations point along the x-axis or y-axis

    if within_angle(fwd_inner_port_angle, 0, 10) or \
       within_angle(fwd_inner_port_angle, 180, 10):
       # If they point along the x-axis, the s-bend's 'length' should be
       # given by horizontal distance, and the bend is reflected across y = 0.
        orient_s_bend = pya.DTrans(pya.DTrans.M90)
        # After an M90 transform,ation the s-bend's port0 is on the right, so 
        # we'll move it to the location of the rightmost internal termination.
        if innermost_fwd_point[0] > innermost_rev_point[0]:
            place_s_bend = pya.DTrans(pya.DVector(
                innermost_fwd_point[0],
                innermost_fwd_point[1]))
        else:
            place_s_bend = pya.DTrans(pya.DVector(
                innermost_rev_point[0],
                innermost_rev_point[1]))

        s_bend_length, s_bend_height = np.abs(
            innermost_fwd_point - innermost_rev_point)

    elif within_angle(fwd_inner_port_angle, 90, 10) or \
        within_angle(fwd_inner_port_angle, 270, 10):
       # If they point along the y-axis, the s-bend's 'length' should be
       # given by vertical distance, and the bend is reflected across y = x.
        orient_s_bend = pya.DTrans(pya.DTrans.M45)
        # After an M45 transformation, the s-bend's port0 is on the left, so 
        # we'll move it to the location of the leftmost internal termination.
        if innermost_fwd_point[0] > innermost_rev_point[0]:
            place_s_bend = pya.DTrans(pya.DVector(
                innermost_rev_point[0],
                innermost_rev_point[1]))
        else:
            place_s_bend = pya.DTrans(pya.DVector(
                innermost_fwd_point[0],
                innermost_fwd_point[1]))
        s_bend_height, s_bend_length = np.abs(
            innermost_fwd_point - innermost_rev_point)
    else:
        raise RuntimeError(
            "It looks like the 'arithmetic_spiral_segments' function isn't "
            + "effectively locating points on the spiral that are tangent to "
            + "the x and y axes. This may be because n_pts is too small.")

    if origin != 'center': 
        raise Warning(
            "Values of 'origin' other than 'center' not yet supported.")

    # Generate the s-bend with the determined dimensions and orientation
    s_bend_trans = trans * place_s_bend * orient_s_bend
    s_bend_pcell = s_bend(layout, layer, s_bend_length, s_bend_height,
        wg_width=wg_width, origin='port0', trans=s_bend_trans)

    # Generate the spiral arms as DPaths
    fwd_spiral_path = pya.DPath(fwd_spiral_Dpoints, wg_width).transformed(trans)
    rev_spiral_path = pya.DPath(rev_spiral_Dpoints, wg_width).transformed(trans)

    # Insert it all into the passed cell
    cell.shapes(layer).insert(fwd_spiral_path)
    cell.shapes(layer).insert(rev_spiral_path)
    cell.insert(s_bend_pcell)

    return


def delay_spiral_geo_alength(turns, spacing, vertical=0, 
    horizontal=0, quad_shift=0, horizontal_mode='symmetric', 
    vertical_mode='symmetric', start_turn=1, start_angle=0, fwd_end_angle=0, 
    rev_end_angle=0, radial_shift=0, xy_ext_arr=None,
    wg_width=wg_width, n_pts=5000, verbose=False):
    '''
    Returns the arc length of the spiral generated by 'delay_spiral_geo' when
    supplied with the same parameters.

    Args:
        turns:          Number of full turns each spiral will make.
                        <int>

        spacing:        Distance between the edges of successive waveguides.
                        <float or int>

        vertical:       Length of vertical straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the extra
                        value are ignored. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        horizontal:     Length of horizontal straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the list will
                        simply be truncated. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        quad_shift:     When vertical or horizontal is supplied as a list,
                        'quad_shift' changes the interface between quadrants
                        at which the vertical/horiztontal shift goes from 
                        one entry in the list to the next. When inserting 
                        space between spiral arms, this manifests as shifting
                        the location at which a pair of arms diverges to make
                        that space. This is primarily useful for changing the
                        angular position of inserted space between arms. It is 
                        also the only way to insert space directly between the 
                        center s-bend and the innermost spiral arms, for which
                        a quad shift of 2 should suffice.

                        Positive values will shift the interface inwards along
                        the spiral, and vice-versa. Only even integers should
                        be supplied, or else the spiral will be contorted in
                        undesirable ways.
                        <int>
                        (default: 0)

        vertical_mode:  Determines how the spiral will be extended in the
                        vertical direction. The strings 'symmetric', 'top'
                        or 'bottom' may be passed.

                        'top':
                            Only the spiral segments in the top half (positive
                            y) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the top segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the top
                            half of the spiral between two turns.

                        'bottom':
                            Only the spiral segments in the bottom half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the bottom segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            bottom half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'vertical', so that
                            the total length of the extensions is the value 
                            of 'vertical'. NOTE: if an array of non-
                            identical values is passed in 'vertical', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of vertical[i], but of
                            (vertical[i] + vertical[i - 1]) / 2.

        horizontal_mode: Determines how the spiral will be extended in the
                        horizontal direction. The strings 'symmetric', 'left'
                        or 'right' may be passed.

                        'right':
                            Only spiral segments in the right half (positive
                            x) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the right segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the right
                            half of the spiral between two turns.

                        'left':
                            Only the spiral segments in the left half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the left segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            left half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'horizontal', so that
                            the total length of the extensions is the value 
                            of 'horizontal'. NOTE: if an array of non-
                            identical values is passed in 'horiztonal', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of horizontal[i], but of
                            (horiztonal[i] + horizontal[i - 1]) / 2.

        xy_ext_arr:     In the event that the parameters above do not 
                        provide enough generality for the sorts of lateral 
                        extensions the user would like to implement, the 
                        user may pass their own 3 dimensional ndarray to the
                        'shift' arg of the function 
                        'arithmetic_spiral_extension'. If shift is None, then 
                        it is constructed from the other arguments. For 
                        example, when both vertical and horiztonal extension 
                        modes are 'symmetric', the 'shift' array generated
                        looks like this:
                            shift = np.array([
                                [ horizontal / 2,  vertical / 2], # quadrant 0
                                [-horizontal / 2,  vertical / 2], # quadrant 1
                                [-horizontal / 2, -vertical / 2], # quadrant 2
                                [ horizontal / 2, -vertical / 2], # quadrant 3
                            ])

                        where both 'horizontal' and 'vertical' are 1D arrays.
                        The entry labelled 'quadrant 0' is the x, y 
                        translation applied to the segment of the spiral
                        in quadrant 0, and so on.

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer.
                        <int>

        start_angle:    Starting angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        end_angle:      End angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        radial_shift:   Shifts the radius uniformly. In the spiral
                        equation r = b * theta + a, a = radial_shift.
                        <float or int>
                        (default: 0)

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points defining each of the intertwined
                        spiral paths.
                        <int>
                        (default: 5000)

        verbose:        If True, prints the arc lengths for the s-bend, 
                        spiral extension lengths, and unextended spiral arc
                        lengths for the forward and reverse spirals separately
                        <bool>
                        (default: False)
    '''
    # 
    # Compute the cooridnates of the basic, segmented, and extended spirals
    #

    # Generate coordinates for a basic spiral curve. Note we need to supply
    # spacing between waveguide centers here (i.e., DPath spines), and double
    # it so that spacing between arms of intertwined spirals equals 'spacing'.
    fwd_coords = arithmetic_spiral_curve(
        turns, 
        2 * (spacing + wg_width), 
        n_pts, 
        start_turn=start_turn, 
        start_angle=start_angle, 
        end_angle=fwd_end_angle, 
        radial_shift=radial_shift)

    # Generate the same spiral reflected about the origin. This way we have
    # outgoing and ingoing spirals intertwined
    rev_coords = arithmetic_spiral_curve(
        turns, 
        -2 * (spacing + wg_width), 
        n_pts, 
        start_turn=start_turn, 
        start_angle=start_angle, 
        end_angle=rev_end_angle, 
        radial_shift=-radial_shift)


    # Divide the spiral into segments whose terminations point in the
    # x and y directions.
    fwd_spiral_segs = arithmetic_spiral_segments(fwd_coords)
    rev_spiral_segs = arithmetic_spiral_segments(rev_coords)    

    # Extend the spiral in the x and y directions as desired by inserting 
    # straight segments of the desired lengths.
    fwd_extended_segs = arithmetic_spiral_extension(
        fwd_coords, vertical, horizontal, quad_shift,
        vertical_mode=vertical_mode,
        horizontal_mode=horizontal_mode,
        shift=xy_ext_arr,
        concatenate=False)

    rev_extended_segs = arithmetic_spiral_extension(
        rev_coords, vertical, horizontal, quad_shift,
        vertical_mode=vertical_mode,
        horizontal_mode=horizontal_mode,
        shift=xy_ext_arr,
        concatenate=False)


    #
    # Compute the length contributed by the spiral sans extensions
    #

    # Find the interval of theta over which the truncated spiral is defined.
    fwd_innermost_point = fwd_spiral_segs[0][:, 0]
    rev_innermost_point = rev_spiral_segs[0][:, 0]

    fwd_innermost_x, fwd_innermost_y = fwd_innermost_point
    rev_innermost_x, rev_innermost_y = rev_innermost_point
    fwd_outermost_x, fwd_outermost_y = fwd_spiral_segs[-1][:, -1]
    rev_outermost_x, rev_outermost_y = rev_spiral_segs[-1][:, -1]

    # From the radii at the terminals of the spiral and its parameters,
    # we can calculate the full range of theta over which the spiral was
    # generated, without being restricted to theta \in [0, 2 pi].
    fwd_start_radius = np.sqrt(fwd_innermost_x ** 2 + fwd_innermost_y ** 2)
    rev_start_radius = np.sqrt(rev_innermost_x ** 2 + rev_innermost_y ** 2)
    fwd_end_radius   = np.sqrt(fwd_outermost_x ** 2 + fwd_outermost_y ** 2)
    rev_end_radius   = np.sqrt(rev_outermost_x ** 2 + rev_outermost_y ** 2)

    # Need spacing between waveguide centers since we're calculating the
    # length of the curve defining the path.
    b = 2 * (spacing + wg_width) / (2 * np.pi)

    fwd_start_theta = (fwd_start_radius - radial_shift) / b
    fwd_end_theta   = (fwd_end_radius   - radial_shift) / b
    rev_start_theta = (rev_start_radius - radial_shift) / b
    rev_end_theta   = (rev_end_radius   - radial_shift) / b


    # Gives the length of the spirals sans the straight-segment extensions
    fwd_spiral_length = arithmetic_spiral_alength(b, radial_shift, 
        fwd_start_theta, fwd_end_theta)
    rev_spiral_length = arithmetic_spiral_alength(b, radial_shift, 
        rev_start_theta, rev_end_theta)


    #
    # Compute the length contributed by the straight-segment extensions
    #

    def ext_length(segs):
        '''Computes total length of extensions to delay spiral'''
        total_extension_length = 0
        for i in range(len(segs) - 1):
            # displacement vector from the end of the ith segment to the
            # start of the (i + 1)th segment.
            disp_vector = segs[i + 1][:, 0] - segs[i][:, -1]

            # Since we expect a purely horiztonal or vertical displacement
            # vector (cooresponding to extensions along x and y only), the
            # straight extension length can be computed simply as the sum
            # of the displacement in the x and y directions, since one of the
            # two directions will have 0 displacement.
            total_extension_length += np.abs(disp_vector[0] + disp_vector[1])
        return total_extension_length

    fwd_extensions_length = ext_length(fwd_extended_segs)
    rev_extensions_length = ext_length(rev_extended_segs)


    #
    # Compute the length contributed by the s-bend in the middle
    #

    # Figure out which directions the inner terminations of the spiral are
    # facing so we can connect them with an appropriate s-bend
    fwd_inner_port_dx, fwd_inner_port_dy = \
        fwd_extended_segs[0][:, 0] - fwd_extended_segs[0][:, 1]
    fwd_inner_port_angle = np.arctan2(fwd_inner_port_dy, fwd_inner_port_dx)
    fwd_inner_port_angle = ma.degrees(fwd_inner_port_angle)

    # The s-bend needs to be oriented differently depending on whether the 
    # inner terminations point along the x-axis or y-axis

    if within_angle(fwd_inner_port_angle, 0, 10) or \
       within_angle(fwd_inner_port_angle, 180, 10):

        s_bend_length, s_bend_height = np.abs(
            fwd_innermost_point - rev_innermost_point)

    elif within_angle(fwd_inner_port_angle, 90, 10) or \
        within_angle(fwd_inner_port_angle, 270, 10):

        s_bend_height, s_bend_length = np.abs(
            fwd_innermost_point - rev_innermost_point)
    else:
        raise RuntimeError(
            "It looks like the 'arithmetic_spiral_segments' function isn't "
            + "effectively locating points on the spiral that are tangent to "
            + "the x and y axes. This may be because n_pts is too small.")

    s_bend_arc_length_ = s_bend_alength(s_bend_length, s_bend_height)

    if verbose:
        print("Fwd spiral length: {} um".format(fwd_spiral_length))
        print("Fwd extensions length: {} um".format(fwd_extensions_length))
        print("Rev spiral length: {} um".format(rev_spiral_length))
        print("Rev extensions length: {} um".format(rev_extensions_length))
        print("S-bend length: {} um".format(s_bend_arc_length_))

    total_arc_length = fwd_spiral_length + fwd_extensions_length + \
        rev_spiral_length + rev_extensions_length + s_bend_arc_length_

    return total_arc_length


def arithmetic_spiral_alength(b, a, theta0, theta1):
    '''
    The formula for the arc length of the arithmetic spiral curve
    r = (b * theta) + a, for theta \\in [theta0, theta1], in radians.
    '''
    def indef_integral(b, a, theta):
        '''
        Simplified formula for the indefinite arc length integral below
        \\int{\\sqrt{r^2 + (dr/dtheta)^2}},
        where r = (b * theta) + a, and theta is in radians.
        '''
        sqrt_term = np.sqrt(b**2 + (b * theta + a)**2)
        pre_factor = 1 / (2 * b)

        return pre_factor * (
                    ((b * theta + a) * sqrt_term) +
                    (b**2 * np.log(b * theta + a + sqrt_term))
                )
    #enddef

    return indef_integral(b, a, theta1) - indef_integral(b, a, theta0)


def arithmetic_spiral_extension(coords, vertical, horizontal, quad_shift=0,
    vertical_mode='symmetric', horizontal_mode='symmetric', shift=None,
    concatenate=True):
    '''
    This function adds straight segments parallel to the x and y axes into
    an arithmetic spiral defined by 'coords', thereby allowing the spiral to 
    be extended in the x and y directions independently.

    Args:
        coords:         Cartesian coordinates defining an arithmetic spiral.
                        First column x coords. Second column y coords.
                        <np.ndarray of floats with shape (2, n)>

        vertical:       Length of vertical straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the extra
                        value are ignored. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        horizontal:     Length of horizontal straight segments to be inserted.
                        If list, the nth entry specifies the  length of
                        the segment inserted in the nth turn of the spiral. 
                        This means that each entry in the array will hold the
                        length of two inserted segments on either side of the
                        spiral.
                        If more values are supplied than turns, the list will
                        simply be truncated. If fewer values are supplied than
                        turns, the function will raise an exception.
                        <float or int or list>

        quad_shift:     When vertical or horizontal is supplied as a list,
                        'quad_shift' changes the interface between quadrants
                        at which the vertical/horiztontal shift goes from 
                        one entry in the list to the next. When inserting 
                        space between spiral arms, this manifests as shifting
                        the location at which a pair of arms diverges to make
                        that space. This is primarily useful for changing the
                        angular position of inserted space between arms. It is 
                        also the only way to insert space directly between the 
                        center s-bend and the innermost spiral arms, for which
                        a quad shift of 2 should suffice.

                        Positive values will shift the interface inwards along
                        the spiral, and vice-versa. Only even integers should
                        be supplied, or else the spiral will be contorted in
                        undesirable ways.
                        <int>
                        (default: 0)

        vertical_mode:  Determines how the spiral will be extended in the
                        vertical direction. The strings 'symmetric', 'top'
                        or 'bottom' may be passed.

                        'top':
                            Only the spiral segments in the top half (positive
                            y) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the top segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the top
                            half of the spiral between two turns.

                        'bottom':
                            Only the spiral segments in the bottom half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the bottom segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            bottom half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'vertical', so that
                            the total length of the extensions is the value 
                            of 'vertical'. NOTE: if an array of non-
                            identical values is passed in 'vertical', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of vertical[i], but of
                            (vertical[i] + vertical[i - 1]) / 2.

        horizontal_mode: Determines how the spiral will be extended in the
                        horizontal direction. The strings 'symmetric', 'left'
                        or 'right' may be passed.

                        'right':
                            Only spiral segments in the right half (positive
                            x) portion of the spiral are translated to make
                            the extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the right segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the right
                            half of the spiral between two turns.

                        'left':
                            Only the spiral segments in the left half
                            of the spiral are translated to make the 
                            extensions. The extension length issue present
                            in symmetric extension mode is not present here,
                            since only the left segments are moved. A 
                            transition in extension length between turns 
                            will correspond to adding space in just the 
                            left half of the spiral between two turns.

                        'symmetric':
                            In symmetric extension mode, the straight
                            extensions are generated by shifting the spiral
                            segments on either side of the straight extensions
                            by half the value passed in 'horizontal', so that
                            the total length of the extensions is the value 
                            of 'horizontal'. NOTE: if an array of non-
                            identical values is passed in 'horiztonal', then
                            at the straight extension on the interface across
                            which we proceed to the next element of the array,
                            the two spiral segments will be shifted by
                            different distances, the latter by the distance
                            specified by the ith element of the array, the 
                            former by the (i - 1)th element, and thus the
                            straight segment at such an interface will not
                            have a length of horizontal[i], but of
                            (horiztonal[i] + horizontal[i - 1]) / 2.

        shift:          In the event that the parameters above do not 
                        provide enough generality for the sorts of lateral 
                        extensions the user woul like to implement, the 
                        user may pass their own 3 dimensional ndarray to
                        'shift'. If shift is None, then it is constructed
                        from the other arguments. For example, when both
                        vertical and horiztonal extension modes are 'symmetric',
                        the 'shift' array generated looks like this:

                            shift = np.array([
                                [ horizontal / 2,  vertical / 2], # quadrant 0
                                [-horizontal / 2,  vertical / 2], # quadrant 1
                                [-horizontal / 2, -vertical / 2], # quadrant 2
                                [ horizontal / 2, -vertical / 2], # quadrant 3
                            ])

                        where both 'horizontal' and 'vertical' are 1D arrays.
                        The entry labelled 'quadrant 0' is the x, y 
                        translation applied to the segment of the spiral
                        in quadrant 0, and so on.

    Return:
        Coordinates of the extended spiral. 
        First column x coords. Second column y coords.
        <2D np.ndarray>
    '''
    # Divide up the spiral into quarters whose endpoints point parallel to 
    # the x and y axes.
    spiral_segs = arithmetic_spiral_segments(coords)

    # Figure out which quadrant the first segment is in and which way
    # the spiral rotates. We'll use two adjacent points about in the middle
    # of the first segment to do this.
    first_seg = spiral_segs[0]
    sample1_index = int(len(first_seg) // 2)
    sample2_index = int(len(first_seg) // 2 + 1)
    sample1_x, sample1_y = first_seg[:, sample1_index]
    sample2_x, sample2_y = first_seg[:, sample2_index]
    sample1_angle = ma.atan2(sample1_y, sample1_x)
    sample2_angle = ma.atan2(sample2_y, sample2_x)

    # Map angles to between 0 and 2 pi
    if sample1_angle < 0: sample1_angle += 2 * np.pi
    if sample2_angle < 0: sample2_angle += 2 * np.pi

    if sample2_angle > sample1_angle:  # if clockwise
        direction = 1   # next quadrant gotten by incrementing
    else:                              # if counter-clockwise
        direction = -1  # next quadrant gotten by decrementing

    quadrant = int(sample1_angle // (np.pi / 2))   # zero-indexing quadrants
    start_quad = quadrant

    if shift is None:
        total_turns = len(spiral_segs) // 2 + 1
        if type(vertical) == int or type(vertical) == float:
            vertical = np.full(total_turns, vertical, np.float)
        if type(horizontal) == int or type(horizontal) == float:
            horizontal = np.full(total_turns, horizontal, np.float)

        if vertical_mode == 'symmetric':
            # TODO: handle off-by-one error with symmetric extensions
            vertical_shifts = np.array([
                 vertical / 2,                  # quadrant 0
                 vertical / 2,                  # quadrant 1
                -vertical / 2,                  # quadrant 2
                -vertical / 2])                 # quadrant 3

        elif vertical_mode == 'top':
            vertical_shifts = np.array([
                vertical,                       # quadrant 0
                vertical,                       # quadrant 1
                np.zeros(vertical.size),        # quadrant 2
                np.zeros(vertical.size)])       # quadrant 3

        elif vertical_mode == 'bottom':
            vertical_shifts = np.array([
                np.zeros(vertical.size),        # quadrant 0
                np.zeros(vertical.size),        # quadrant 1
                -vertical,                      # quadrant 2
                -vertical])                     # quadrant 3

        else:
            raise ValueError(
                "Expected one of the strings 'symmetric', 'top', or 'bottom' "
                + "to be passed to the argument 'vertical_mode'. "
                + "Instead got '{}'.".format(vertical_mode))
            
        if horizontal_mode == 'symmetric':
            horizontal_shifts = np.array([
                 horizontal / 2,                # quadrant 0
                -horizontal / 2,                # quadrant 1
                -horizontal / 2,                # quadrant 2
                 horizontal / 2])               # quadrant 3

        elif horizontal_mode == 'right':
            horizontal_shifts = np.array([
                horizontal,                     # quadrant 0
                np.zeros(horizontal.size),      # quadrant 1
                np.zeros(horizontal.size),      # quadrant 2
                horizontal])                    # quadrant 3

        elif horizontal_mode == 'left':
            horizontal_shifts = np.array([
                np.zeros(horizontal.size),      # quadrant 0
                -horizontal,                    # quadrant 1
                -horizontal,                    # quadrant 2
                np.zeros(horizontal.size)])     # quadrant 3

        else:
            raise ValueError(
                "Expected one of the strings 'symmetric', 'left', or 'right' "
                + "to be passed to the argument 'horizontal_mode'. "
                + "Instead got '{}'.".format(horizontal_mode))

        shift = np.stack((horizontal_shifts, vertical_shifts), axis=1)
        # For reference, if both vertical and horizontal modes are symmetric,
        # the 'shift' array would look like this:
        #
        # shift = np.array([
        #     [ horizontal / 2,  vertical / 2],   # quadrant 0
        #     [-horizontal / 2,  vertical / 2],   # quadrant 1
        #     [-horizontal / 2, -vertical / 2],   # quadrant 2
        #     [ horizontal / 2, -vertical / 2],   # quadrant 3
        # ])

    # endif

    # TODO: document start_quad, quad_shift, and the weird indexing introduced.
    for idx, seg in enumerate(spiral_segs):
        vert_turn = int((idx - start_quad + quad_shift) // 2)
        hori_turn = int((idx - 1 - start_quad + quad_shift) // 2) 
        if vert_turn < 0: vert_turn = 0
        if hori_turn < 0: hori_turn = 0

        next_shift = np.array([
            shift[quadrant, 0, hori_turn],
            shift[quadrant, 1, vert_turn]
        ])
        # Translate this segment of the spiral appropriately
        spiral_segs[idx] = (seg.transpose() + next_shift).transpose()
        # Compute next quadrant (wraps back to 0 after quadrant 3)
        quadrant = (quadrant + direction) % 4

    # Concatenate and return the transformed segments. Plotting and layout 
    # tools should take care of joining the lines between the ends of each
    # segment of the concatenated array of points.

    if concatenate:
        return np.concatenate(spiral_segs, axis=1)
    else:
        return spiral_segs


def arithmetic_spiral_segments(coords):
    '''
    Given the cartesian coordiantes of an arithmetic spiral, this function 
    will divide the coordinates into groups such that the ends of each spiral
    segments will be tangent to either the x or y axes.

    Args:
        coords:         Cartesian coordinates defining an arithmetic spiral.
                        First column x coords. Second column y coords.
                        <np.ndarray of floats with shape (2, n)>

    Return:
        spiral_segs:    A list of 2-D numpy arrays, each of which represents
                        the coordinates of one segment.
                        <list of np.ndarrays>
    '''
    # Find indices of the points on the spiral that are parallel to either the
    # x or y axes.
    negy_inds = relex.argrelmin(coords[1])[0]
    posy_inds = relex.argrelmax(coords[1])[0]
    negx_inds = relex.argrelmin(coords[0])[0]
    posx_inds = relex.argrelmax(coords[0])[0]

    # Get the parallel points that will divide the spiral into the desired
    # segments, requested by the 'divison' argument.
    inds = np.concatenate((negy_inds, posy_inds, negx_inds, posx_inds))

    # Figure out how many segments to divide the spiral into.
    num_segs = inds.size - 1

    # Make sure there are enough parallel points for at least 1 full segment.
    if num_segs < 1:
        raise ValueError(
            "The sprial coordinates supplied did not contain a full segment. "
            + "Try supplying coordinates over a larger range, or dividing "
            + "into smaller segments.")

    # The indicies need to be sorted after the concatenation
    inds.sort()

    # Init a list of segments (can't be an np.ndarray since each segment 
    # will be a different length)
    spiral_segs = []

    for i in range(num_segs):
        start = inds[i]
        end = inds[i + 1] + 1
        spiral_segs.append(coords[:, start:end])

    return spiral_segs
    

def arithmetic_spiral_curve(turns, spacing, n_pts, start_turn=0, 
    start_angle=0, end_angle=0, radial_shift=0):
    '''
    Generates an array of Cartesian coordinates defining an arithmetic (aka
    Archimedean) spiral. The range of angles in degrees over which it is 
    plotted is given by 
    start = 360 * turns + start_angle
    end   = start + (360 * turns) + end_angle
    theta \\in [start, end]

    Args:
        turns:          Number of full turns the spiral will make.
                        <int>

        spacing:        Distance between successive wrappings.
                        <float or int>

        n_pts:          Number of points defining the spiral.
                        <int>

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer.
                        <int>

        start_angle:    Starting angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        end_angle:      End angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        radial_shift:   Shifts the radius uniformly. In the spiral
                        equation r = b * theta + a, a = radial_shift.
                        <float or int>
                        (default: 0)

    Return:
        An array of shape (2, n_pts) defining the spiral.
        First column x coords. Second column y coords.
        <2D np.ndarray>
    '''
    if n_pts is None:
        n_pts = 3000 # TODO actual calcualtion
    start_theta = ma.radians(360 * start_turn + start_angle)
    end_theta = start_theta + ma.radians(360 * turns + end_angle)
    theta = np.linspace(start_theta, end_theta, n_pts)

    b = spacing / (2 * np.pi)
    r = radial_shift + (b * theta)

    x, y = polar_to_rect(r, theta)

    return np.stack((x, y))


def polar_to_rect(r, theta):
    '''
    Converts polar coordinates (r, theta) to cartesian cooridnates (x, y).
    theta should be supplied in radians.
    '''
    x = r * np.cos(theta)
    y = r * np.sin(theta)

    return x, y


def rect_to_polar(x, y):
    '''
    Converts Cartesian coordinates (x, y) to polar coordinates (r, theta).
    theta is returned in radians
    '''
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    return r, theta


def parabolic_taper(layout, start_width, end_width, length, 
    seg_length=seg_length, n_pts=None, origin='port0'):
    '''
    Generates a parabolic waveguide taper as a pya.DPolygon object.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        start_width:    Width of the taper at its left end. Must be smaller
                    `   than 'end_width'.
                        <float or int>

        end_width:      Width of the taper at its right end. Must be larger 
                        than 'start_width'.
                        <float or int>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>
                        (default: None)

        seg_length:     When rounding parabola, gives the distance between the
                        points defining it and sets n_pts appropriately. Does
                        this computation using the approximation of a graudal
                        taper (i.e., |start_width - end_width| << length).
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        n_pts:          Number of points defining each parabolic taper. Thus
                        The polygon with have a total of 2 * n_pts points.

        origin:         Indicates the location of the origin relative to 
                        the taper. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Left port (thin end)
                        'center'    Center relative to max device dimensions
                        'port1'     Right port (thick end)

                        <str>
                        (default: 'port0')

    Return:
        A polygon in the shape of a linear taper
        <pya.DPolygon object>
    '''
    if start_width > end_width:
        raise ValueError("Must have start_width < end_width")

    if n_pts is None:
        n_pts = int(round(length / seg_length))

    # x-coordinates
    x_coords = np.linspace(0, length, n_pts)

    # Parameters for the parabola ax^2 + k defining the taper profile
    a = (end_width - start_width) / (2 * length**2)
    k = start_width / 2

    upper_profile =  a * x_coords**2 + k
    lower_profile = -upper_profile

    # Define points in the hull of the taper
    hull_upper = [pya.DPoint(x_coords[i], upper_profile[i]) 
        for i in range(n_pts)]
    hull_lower = [pya.DPoint(x_coords[i], lower_profile[i]) 
        for i in range(n_pts)]

    # instantiate the polygon
    taper = pya.DPolygon(hull_upper + hull_lower[::-1])

    # Shift the taper so that it has the desired coordinate origin.
    if origin == 'center':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length / 2, 0)))
    elif origin == 'port1':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length, 0)))
    elif origin == 'port0':
        pass
    else:
        raise ValueError("Expected arugment 'origin' to be one of 'port0', "
            + "'port1', or 'center'. instead got {}".format(origin))

    return taper


def linear_taper(layout, start_width, end_width, length, origin='port0'):
    '''
    Generates a linear waveguide taper as a pya.DPolygon object.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        start_width:    Width of the taper at its left end
                        <float or int>

        end_width:      Width of the taper at its right end
                        <float or int>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>
                        (default: None)

        origin:         Indicates the location of the origin relative to 
                        the taper. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Left port (thin end)
                        'center'    Center relative to max device dimensions
                        'port1'     Right port (thick end)

                        <str>
                        (default: 'port0')

    Return:
        A polygon in the shape of a linear taper
        <pya.DPolygon object>
    '''
    # Define points in the hull of the taper
    hull = [
        pya.DPoint(0,      -start_width / 2),
        pya.DPoint(0,       start_width / 2),
        pya.DPoint(length,  end_width / 2),
        pya.DPoint(length, -end_width / 2)
    ]

    # instantiate the polygon
    taper = pya.DPolygon(hull)

    # Shift the taper so that it has the desired coordinate origin.
    if origin == 'center':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length / 2, 0)))
    elif origin == 'port1':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length, 0)))
    elif origin == 'port0':
        pass
    else:
        raise ValueError("Expected argument 'origin' to be one of 'port0', "
            + "'port1', or 'center'. instead got {}".format(origin))

    return taper


def s_bend(layout, layer, length=None, height=None, bend_radius=None, 
    bend_angle=None, wg_width=wg_width, n_pts=None, seg_length=seg_length,
    origin='port0', trans=null_trans):
    '''
    Generates a path in the shape of an s-bend. Origin at the lower left port.
        
    The s-bend may be specified by any of the following parameter pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The bend is constrained to be composed entirely of rounded waveguide 
    except when the bend must be particularly steep. In other words, the only
    case in which a straight segment in the middle of the bend is allowed is
    when that straight segment is completely vertical. This is so that the 
    bend radius of the corners is maximized (and thus loss minimized).

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>      

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>
                        (default: None)

        bend_radius:    Radius of corner arcs. If supplied along with length,
                        2 * bend_radius >= length.
                        <float or int or None>
                        (default: None)

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>
                        (default: None)

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the  s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>
                        (default: None)

        wg_width:       Width of the path
                        <float or int>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If None, this is computed based on the
                        value of 'seg_length'.
                        <int or None>
                        (default: None)

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        origin:         Indicates the location of the origin relative to 
                        the s-bend. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Lower left port
                        'center'    Center relative to overall dimensions

                        <str>
                        (default: 'port0')

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell that comprises the s-bend. Applied
                        after the origin of the bend is set.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)


    # Raise an error if the bend has a radius less than the minimum (5 um)
    if bend_radius < min_bend_radius:
        raise ValueError("Computed a bend radius of"
                       + " {} um for the s-bend, ".format(bend_radius)
                       + "which is less than the minimum radius of"
                       + " {} um. Try".format(min_bend_radius)
                       + " making the bends less tight, or lower the value of"
                       + " chickpea.constants.min_bend_radius to stop showing"
                       + " this error.")

    if origin == 'center':
        center_to_origin = pya.DTrans(pya.DVector(-length / 2, -height / 2))
        trans = trans * center_to_origin
    elif origin == 'port0':
        pass
    else:
        raise ValueError(
            "Expected 'center' or 'port0' passed as argument 'origin'. "
            + "Instead got {}".format(origin))

    # KLayout will have trouble properly representing paths that were
    # generated with very small bend angles, since in this limit the two
    # points at the path verticies will be placed past the boundaries of the
    # layout, and we'd get asymmetries, wrap-arounds, etc.
    if not steep_bend and bend_angle < 1e-4:
        # This will approximate bend angles less that 1e-4 degrees as 0.
        return s_bend_double(layout, layer, wg_width=wg_width,
            bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length,
            trans=trans)

    if steep_bend:
        return s_bend_steep(layout, layer, height - 2 * bend_radius, 
            wg_width=wg_width, bend_radius=bend_radius, n_pts=n_pts, 
            seg_length=seg_length, trans=trans)
    else:
        return s_bend_shallow(layout, layer, length, bend_radius, 
            height, bend_angle, wg_width=wg_width, n_pts=n_pts, 
            seg_length=seg_length, trans=trans)


def s_bend_solve_params(length, bend_radius, height, bend_angle):
    '''
    Parses arguments to 's_bend' and calculates the unspecified paramters
    Also raises exceptions in cases with over/underspecification
    of parameters or if unsupported parameter pairs are supplied. Exactly
    two parameters should be supplied and they should be one of the pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The unspecified parameters should be left as None.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>

        bend_radius:    Radius of corner arcs. If supplied along with length,
                        2 * bend_radius >= length.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

    Return:
        steep_bend:     Indicates whether the s-bend is steep, meaning that 
                        the specified parameters must be met with an s-bend 
                        whose middle section goes completely vertical and 
                        whose corners form full 90 degree arcs.
                        <bool>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float>

        bend_radius:    Radius of corner arcs.
                        <float>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float>

    '''
    #
    # Check number of constraints
    #

    args = [length, bend_radius, height, bend_angle]
    unspecified = 0   # number of specified parameters
    for arg in args:
        if arg is None:
            unspecified += 1

    proper_constraints = "Exactly two parameters should be supplied "\
         + "and they should be one of the pairs: " + """
            (length, bend_radius),
            (height, bend_radius)
            (length, height),
            (bend_radius, bend_angle)
        The unspecified parameters should be left as None."""

    if unspecified < 2:
        raise ValueError("S-bend is over-constrained. " + proper_constraints)
    elif unspecified > 2:
        raise ValueError("S-bend is under-constrained. " + proper_constraints)

    #
    # Calculate the unspecified parameters
    #

    # Indicates whether the s-bend is steep, meaning that the specified 
    # parameters must be met with an s-bend whose middle section goes
    # completely vertical and whose corners form full 90 degree arcs.
    steep_bend = False  

    # Compute length and height from bend_angle and bend_radius
    if length is None and height is None:
        bend_angle = ma.radians(bend_angle)
        length, height = s_bend_solve_length_height(bend_angle, bend_radius)

    # Compute bend_radius and bend_angle from length and height
    elif bend_radius is None and bend_angle is None:
        bend_radius = length / 2
        # If the bend is taller than it is long, make it steep, unless the
        # steep bend has a bend radius smaller than the minimum in which
        # case we let shallow_s_bend make a bend that will double back on
        # itself, thus making the bend radius larger.
        steep_bend = height > length and bend_radius >= min_bend_radius
        if not steep_bend:
            bend_angle, bend_radius = s_bend_solve_angle_radius(length, height)

    # Compute height and bend_angle from length and bend_radius
    elif height is None and bend_angle is None:
        # If length > 2 * bend_radius, the s-bend must include a diagonal 
        # straight segment to satisify the length with such a small bend radius.
        # This is not supported for simplicity and because the bend radius
        # should generally be maximized anyway.
        if length > 2 * bend_radius:
            raise ValueError("bend_radius too small. Must have "
                           + "length <= 2 * bend_radius.")
        
        height, bend_angle = s_bend_solve_height_angle(length, bend_radius)

    # Compute length and bend_angle from height and bend_radius
    elif length is None and bend_angle is None:
        steep_bend = height > 2 * bend_radius
        if not steep_bend:
            length, bend_angle = s_bend_solve_length_angle(height, bend_radius)

    # The pair of parameters specified isn't supported, so raise an exception
    else:
        raise ValueError("That parameter pair is not supported " 
            + proper_constraints)

    return steep_bend, length, bend_radius, height, bend_angle


def s_bend_alength(length=None, height=None, bend_radius=None,  
    bend_angle=None):
    '''
    Returns the arc length of the s-bend generated by s_bend when supplied
    with the corresponding arguments.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>
    Return:
        The arc length
        <float>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)

    if steep_bend:
        bend_length = ma.pi * bend_radius
        straight_length = height - 2 * bend_radius
        return  bend_length + straight_length
    else:
        return 2 * bend_radius * (ma.pi - bend_angle)


def s_bend_solve_length_height(bend_angle, bend_radius):
    '''
    Returns the length and height of the s-bend with 'bend_angle' and 
    'bend_radius'.

    Args:
        bend_radius:    Radius of corner arcs.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

    Return: 
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>
    '''
    length = 2 * bend_radius * ma.sin(bend_angle)
    height = 2 * bend_radius * (1 + ma.cos(bend_angle))

    return length, height


def s_bend_solve_angle_radius(length, height):
    '''
    Returns the bend angle and bend radius of the s-bend with overall 
    dimensions of 'length' x 'height'. Only valid for length >= height. The
    parameters are generated with the constraint that there be no straight 
    segment in the middle of the s-bend (thus allowing the largest bend raidus
    possible for the specified dimensions).

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

    Return:
        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>


    '''
    # straight line distance separating s-bend ports, squared
    port_sep_squared = (height ** 2) + (length ** 2)

    bend_radius = port_sep_squared / (4 * height)

    argx = (height**2 - length**2) / port_sep_squared
    argy = (2 * height * length) / port_sep_squared
    bend_angle  = ma.atan2(argy, argx)

    return bend_angle, bend_radius


def s_bend_solve_height_angle(length, bend_radius):
    '''
    Calculates s-bend height and bend angle from length and bend_radius.
    I.e., calculates the parameters most convenient for constructing the 
    s-bend from the default user parameters for the s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

    Return:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>
    '''
    diameter = 2 * bend_radius
    a = ma.sqrt(diameter**2 - length**2)

    height = diameter - a
    bend_angle = ma.pi + ma.atan(-length / a)

    return height, bend_angle


def s_bend_solve_length_angle(height, bend_radius):
    '''
    Calculates s-bend length and bend angle from height and bend_radius.

    Args:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

    Return:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

    '''
    length = ma.sqrt(height * (4 * bend_radius - height))

    argy = length / bend_radius
    argx = (height / bend_radius) - 2

    bend_angle = ma.atan2(argy, argx)

    return length, bend_angle


def s_bend_shallow(layout, layer, length, bend_radius, height, bend_angle, 
    wg_width=wg_width, n_pts=None, seg_length=seg_length, trans=null_trans):
    '''
    Generates a shallow s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''

    x1 = bend_radius * ma.tan((ma.pi - bend_angle) / 2)
    dx = height * ma.tan(bend_angle - (ma.pi / 2))

    points = [
        pya.DPoint(0,       0),
        pya.DPoint(x1,      0),
        pya.DPoint(x1 + dx, height),
        pya.DPoint(length,  height)
    ]

    return path(layout, layer, points, wg_width=wg_width, 
        bend_radius=bend_radius,n_pts=n_pts, seg_length=seg_length, 
        trans=trans)


def s_bend_steep(layout, layer, length, wg_width=wg_width,  
    bend_radius=bend_radius, n_pts=None, seg_length=seg_length, 
    trans=null_trans):
    '''
    Generates a path in the shape of an s-bend with 90 degree bends. A helper
    function for 's_bend' that handles the case height > length.
    Origin at the lower left port.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        length:         Length of straight segment in middle of the s-bend
                        <float>

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If None, this is computed based on the
                        value of 'seg_length'.
                        <int or None>
                        (default: None)

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts is None.
                        <float>
                        (default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    points = [
        pya.DPoint(0,               0                       ),
        pya.DPoint(bend_radius,     0                       ),
        pya.DPoint(bend_radius,     length + 2 * bend_radius),
        pya.DPoint(2 * bend_radius, length + 2 * bend_radius)
    ]

    return path(layout, layer, points, wg_width=wg_width, 
        bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length, 
        trans=trans)


def s_bend_double(layout, layer, wg_width=wg_width, bend_radius=bend_radius, 
    n_pts=None, seg_length=seg_length, trans=null_trans):
    '''
    Generates a path in the shape of an s-bend that doubles back on itself
    such that the horizontal distance between its ports is exactly zero.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If None, this is computed based on the
                        value of 'seg_length'.
                        <int or None>
                        (default: None)

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts is None.
                        <float>
                        (default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    points = [
        pya.DPoint( 0,               0              ),
        pya.DPoint( bend_radius,     0              ),
        pya.DPoint( bend_radius,     2 * bend_radius),
        pya.DPoint(-bend_radius,     2 * bend_radius),
        pya.DPoint(-bend_radius,     4 * bend_radius),
        pya.DPoint( 0,               4 * bend_radius)
    ]

    return path(layout, layer, points, wg_width=wg_width, 
        bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length, 
        trans=trans)


def path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius, 
    n_pts=None, seg_length=seg_length, trans=null_trans):
    '''
    Generates a rounded path PCell from the passed path.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        points:         Array of verticies in the path to be rounded.
                        <2 x n array-like of floats> 
                        OR 
                        <1D array-like of pya.DPoints>

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If None, this is computed based on the
                        value of 'seg_length'.
                        <int or None>
                        (default: None)

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts is None.
                        <float>
                        (default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>

    '''
    # Compute number of points to keep the distance bewteen points on the
    # circle to seg_length
    if n_pts is None:
        n_pts = 2 * ma.pi * bend_radius / seg_length

    # If elements of 'points' aren't DPoints, try to convert them.
    if isinstance(points[0], pya.DPoint) == False:
        for point, idx in enumerate(points):
            points[idx] = pya.DPoint(p[0], p[1])

    path = pya.DPath(points, wg_width)

    basic_lib = pya.Library.library_by_name("Basic")
    pcell_dec = basic_lib.layout().pcell_declaration("ROUND_PATH")
    layer_name = layout.layer_infos()[layer]

    parameters = {
        "layer":   layer_name, 
        "radius":  bend_radius, 
        "path":    path, 
        "npoints": n_pts
    }

    pcell_idx = layout.add_pcell_variant(basic_lib, pcell_dec.id(), parameters)

    pcell = pya.DCellInstArray(pcell_idx, trans)

    return pcell


def array_to_DPoints(arr):
    '''
    Converts an ndarray of coordinates to a list of DPoints
    '''
    dpts = []

    for i in range(arr.shape[1]):
        dpts.append(pya.DPoint(arr[0, i], arr[1, i]))

    return dpts


def path_ports(path):
    '''
    Computes the locations and direction of the ports of a path
    TODO: Need to test if this works
    '''
    dpts = list(path.each_point())

    first_segment = dpts[0] - dpts[1]
    port0_angle = ma.atan2(first_segment.y, first_segment.x)
    port0_loc = dpts[0]

    last_segment = dpts[-1] - dpts[-2]
    port1_angle = ma.atan2(last_segment.y, last_segment.x)
    port1_loc = dpts[-1]

    return [[port0_loc, port0_angle], [port1_loc, port1_angle]]


def within_number(actual, nominal, tolerance):
    '''
    Checks wheter a number 'actual' is within 'tolerance' of a nominal value.
    '''
    lower_bound = nominal - tolerance
    upper_bound = nominal + tolerance
    return lower_bound <= actual and actual <= upper_bound


def within_angle(actual, nominal, tolerance):
    '''
    Checks whether an angle 'acutal' is within 'tolerance' of a nominal angle
    'nominal', accounting for modularity. Arguments must be in degrees.
    '''
    if actual < 0:
        actual += 360
    lower_bound = (nominal - tolerance) % 360
    if lower_bound < 0:
        lower_bound += 360
    upper_bound = ((nominal + tolerance) % 360) - lower_bound
    if upper_bound < 0:
        upper_bound += 360
    actual = (actual % 360) - lower_bound
    if actual < 0:
        actual += 360

    return actual <= upper_bound


def arc_length(arr):
    alength = 0
    for i in range(arr.shape[1] - 1):
        alength += np.sqrt(np.sum(np.power(arr[:, i + 1] - arr[:, i], 2)))
    return alength
