# This file contains functions for generating various photonic waveguide paths
# in KLayout. The top-level functions are as follows:
#
#   path                            - wrapper around round path pcell.
#   s_bend(length, height)          - generates an s-bend, maximizing bend 
#                                     radius for the specified length and height
#   s_bend(bend_angle, bend_radius) - generates an s-bend with specified bend
#                                     parameters
#   s_bend(length, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total length
#   s_bend(height, bend_radius)     - generates an s-bend with specified bend
#                                     radius and total height
#   s_bend_path_length              - calculates path length of the s-bend
#                                     generated by s_bend when supplied with
#                                     corresponding parameters.
#
# Revision History:
# 25 Jun 2019   Julian Sanders  Inital Revision
# 26 Jun 2019   Julian Sanders  Added s-bends
# 28 Jun 2019   Julian Sanders  Debugging and documentation
# 03 Jun 2019   Julian Sanders  Updated constants to be lowercase
# 05 Jul 2019   Julian Sanders  Updated for new package name 'chickpea'.
# 10 Jul 2019   Julian Sanders  Changed shallow s-bend generation from an 
#                               overcomplicated polynomial to circular bends.
# 24 Jul 2019   Julian Sanders  Added function for generating linear and
#                               parabolic tapers.
# 28 Jul 2019   Julian Sanders  Round paths are now generated as PCells rather
#                               than as raw DPaths.
# 30 Jul 2019   Julian Sanders  Added functions to generate coordinates 
#                               defining an arithmetic spiral, and functions
#                               on those coordinates that divide the spiral
#                               into segments with axis-aligned endpoints and
#                               a function that can extend the spiral in x and
#                               y directions by translating these segments.
# 31 Jul 2019   Julian Sanders  Minimal implementation of fully parametrized
#                               delay spiral. 


import pya
import math as ma
import numpy as np
import chickpea.scipy_relex as relex
from chickpea.constants import *
from chickpea.transforms import null_trans



def delay_spiral(layout, layer, cell, path_length, spacing, 
    sbend_raidus=bend_radius, port0_side='left', port1_side='right', 
    length_adjust=0, height_adjust=0, wg_width=wg_width, n_pts=None, 
    seg_length=seg_length, origin='center', trans=null_trans):
    '''
    Populates 'cell' with a delay spiral composed of two intertwined extended
    arithmetic/Archimedean spirals joined by an s-bend in the center. 

    Parameters available to the user are optimized for photonic design. 
    For an equivalent parameter set directly related to the spiral geometry, 
    see 'delay_spiral_geo'.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        cell:           Index of the cell to insert the directional coupler
                        into (this is the value returned by the method
                        'layout.create_cell').
                        <int>

        path_length:    Length along the spine of the delay spiral path.
                        <float>

        spacing:        Distance between the centers of successive waveguides.
                        <float or int>

        sbend_radius:   Bend radius of the s-bend joining the spirals at
                        their centers.
                        <float or int>
                        (default: constants.bend_radius == 10)

        port0_side:     Indicates which side of the spiral port 0 will be. Can
                        be either 'left', 'right', 'bottom', or 'top'.
                        <str>
                        (default: 'left')

        port1_side:     Indicates which side of the spiral port 1 will be. Can
                        be either 'left', 'right', 'bottom', or 'top'.
                        <str>
                        (default: 'bottom')

        length_adjust:  The length of the straight segments extending the
                        spiral in the x direction will be computed to satisfy 
                        the desired value of 'sbend_radius'. 'length_adjust' 
                        will be added to this value so that the actual 
                        straight segment extension of the spiral in the x 
                        direction is given by computed_length + length_adjust.

                        Setting 'length_adjust' to a non-zero value may cause 
                        the actual s-bend radius to differ from the value 
                        'sbend_radius'.

                        <float or int>
                        (default: 0)

        height_adjust:  The length of the straight segments extending the
                        spiral in the y direction will be computed to satisfy 
                        the desired value of 'sbend_radius'. 'height_adjust' 
                        will be added to this value so that the actual  
                        straight segment extension of the spiral in the y 
                        direction is given by computed_height + height_adjust.

                        Setting 'height_adjust' to a non-zero value may cause 
                        the actual s-bend radius to differ from the value 
                        'sbend_radius'.

                        <float or int>
                        (default: 0)

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points defining the entire delay spiral. If 
                        None, this is computed based on the value of 
                        'seg_length'. Note that this parameter will affect how 
                        close the port directions get to a multiple of 
                        90 degrees.
                        <int or str>
                        (default: None)

        seg_length:     Gives the distance between the points defining the 
                        spiral and sets n_pts appropriately. Note that this 
                        parameter will affect how close the port directions
                        get to a multiple of 90 degrees.
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        origin:         Indicates the location of the origin relative to 
                        the s-bend. Can be 'port0', 'port1' or 'center'.

                        value       origin location
                        ------------------------------------------------------
                        'port0'     Port at location specified by 'port0_side'
                        'port1'     Port at location specified by 'port1_side'
                        'center'    Center relative to overall dimensions

                        <str>
                        (default: 'center')

        trans:          A transformation upon the entire spiral before
                        it is inserted into the passed cell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)
    '''

    pass


def delay_spiral_geo(layout, layer, cell, turns, spacing, vertical=0, 
    horizontal=0, start_turn=0, start_angle=0, end_angle=0, radial_shift=0, 
    wg_width=wg_width, n_pts=3000, origin='center', trans=null_trans):
    '''
    Populates 'cell' with a delay spiral composed of two intertwined extended
    arithmetic/Archimedean spirals joined by an s-bend in the center. 

    Parameters available to the user are directly related to the spiral 
    geometry, hence the suffix '_geo'. For an equivalent parameter set 
    optimized for photonic design, see 'delay_spiral'.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        cell:           Index of the cell to insert the directional coupler
                        into (this is the value returned by the method
                        'layout.create_cell').
                        <int>

        turns:          Number of full turns the spiral will make.
                        <int>

        spacing:        Distance between the centers of successive waveguides.
                        <float or int>

        vertical:       Length of vertical straight segments to be inserted.
                        <float or int>

        horizontal:     Length of horizontal straight segments to be inserted.
                        <float or int>

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer.
                        <int>

        start_angle:    Starting angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        end_angle:      End angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        radial_shift:   Shifts the radius uniformly. In the spiral
                        equation r = b * theta + a, a = radial_shift.
                        <float or int>
                        (default: 0)

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points defining the entire delay spiral.
                        <int>
                        (default: 3000)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell that comprises the s-bend.
                        <pya.DTrans object>
                        (default: transforms.null_trans)
    Return:

    '''
    # Generate coordinates for a basic spiral curve
    fwd_coords = arithmetic_spiral_curve(turns, 2 * spacing, n_pts, 
        start_turn=start_turn, start_angle=start_angle, end_angle=end_angle, 
        radial_shift=radial_shift)

    # Generate the same spiral reflected about the origin. This way we have
    # outgoing and ingoing spirals intertwined
    rev_coords = arithmetic_spiral_curve(turns, -2 * spacing, n_pts, 
        start_turn=start_turn, start_angle=start_angle, end_angle=end_angle, 
        radial_shift=-radial_shift)

    # Extend the spiral in the x and y directions as desired by inserting 
    # straight segments of the desired lengths.
    fwd_spiral_points = arithmetic_spiral_extension(
        fwd_coords, vertical, horizontal)
    rev_spiral_points = arithmetic_spiral_extension(
        rev_coords, vertical, horizontal)

    # Convert the ndarrays of coordinates to lists of DPoints so we can 
    # make KLayout DPaths out of them.
    fwd_spiral_Dpoints = array_to_DPoints(fwd_spiral_points)
    rev_spiral_Dpoints = array_to_DPoints(rev_spiral_points)

    # Figure out which directions the inner terminations of the spiral are
    # facing so we can connect them with an appropriate s-bend
    fwd_first_segment = fwd_spiral_Dpoints[0] - fwd_spiral_Dpoints[1]
    fwd_inner_port_angle = np.arctan2(fwd_first_segment.y, fwd_first_segment.x)
    fwd_inner_port_angle = ma.degrees(fwd_inner_port_angle)

    # Get the innermost points of the forward and reverse spirals. These are
    # the points the s-bend needs to connect, and will determine how long
    # and tall the s-bend is.
    innermost_fwd_point = fwd_spiral_points[:, 0]
    innermost_rev_point = rev_spiral_points[:, 0]

    # The s-bend needs to be oriented differently depending on whether the 
    # inner terminations point along the x-axis or y-axis

    if within_angle(fwd_inner_port_angle, 0, 10) or \
       within_angle(fwd_inner_port_angle, 180, 10):
       # If they point along the x-axis, the s-bend's 'length' should be
       # given by horizontal distance, and the bend is reflected across y = 0.
        orient_s_bend = pya.DTrans(pya.DTrans.M90)
        s_bend_length, s_bend_height = np.abs(
            innermost_fwd_point - innermost_rev_point)

    elif within_angle(fwd_inner_port_angle, 90, 10) or \
         within_angle(fwd_inner_port_angle, 270, 10):
       # If they point along the y-axis, the s-bend's 'length' should be
       # given by vertical distance, and the bend is reflected across y = x.
        orient_s_bend = pya.DTrans(pya.DTrans.M45)
        s_bend_height, s_bend_length = np.abs(
            innermost_fwd_point - innermost_rev_point)
    else:
        raise RuntimeError(
            "It looks like the 'arithmetic_spiral_segments' function isn't "
            + "effectively locating points on the spiral that are tangent to "
            + "the x and y axes. This may be because n_pts is too small.")

    # Generate the s-bend with the determined dimensions and orientation
    s_bend_trans = trans * orient_s_bend
    s_bend_pcell = s_bend(layout, layer, s_bend_length, s_bend_height,
        wg_width=wg_width, origin='center', trans=s_bend_trans)

    # Generate the spiral arms as DPaths
    fwd_spiral_path = pya.DPath(fwd_spiral_Dpoints, wg_width).transformed(trans)
    rev_spiral_path = pya.DPath(rev_spiral_Dpoints, wg_width).transformed(trans)

    # Insert it all into the passed cell
    cell.shapes(layer).insert(fwd_spiral_path)
    cell.shapes(layer).insert(rev_spiral_path)
    cell.insert(s_bend_pcell)

    return


def arithmetic_spiral_extension(coords, vertical, horizontal):
    '''
    This function adds straight segments parallel to the x and y axes into
    an arithmetic spiral defined by 'coords', thereby allowing the spiral to 
    be extended in the x and y directions independently.

    Args:
        coords:         Cartesian coordinates defining an arithmetic spiral.
                        First column x coords. Second column y coords.
                        <np.ndarray of floats with shape (2, n)>

        vertical:       Length of vertical straight segments to be inserted.
                        <float or int>

        horizontal:     Length of horizontal straight segments to be inserted.
                        <float or int>

    Return:
        Coordinates of the extended spiral. 
        First column x coords. Second column y coords.
        <2D np.ndarray>
    '''
    # Divide up the spiral into quarters whose endpoints point parallel to 
    # the x and y axes.
    spiral_segs = arithmetic_spiral_segments(coords)

    # Figure out which quadrant the first segment is in and which way
    # the spiral rotates. We'll use two adjacent points about in the middle
    # of the first segment to do this.
    first_seg = spiral_segs[0]
    sample1_index = int(len(first_seg) // 2)
    sample2_index = int(len(first_seg) // 2 + 1)
    sample1_x, sample1_y = first_seg[:, sample1_index]
    sample2_x, sample2_y = first_seg[:, sample2_index]
    sample1_angle = ma.atan2(sample1_y, sample1_x)
    sample2_angle = ma.atan2(sample2_y, sample2_x)

    if sample2_angle > sample1_angle:  # if clockwise
        direction = 1   # next quadrant gotten by incrementing
    else:                              # if counter-clockwise
        direction = -1  # next quadrant gotten by decrementing

    quadrant = int(sample1_angle // (np.pi / 2))   # zero-indexing quadrants

    shift = np.array([
        [ horizontal / 2,  vertical / 2],   # quadrant 0
        [-horizontal / 2,  vertical / 2],   # quadrant 1
        [-horizontal / 2, -vertical / 2],   # quadrant 2
        [ horizontal / 2, -vertical / 2],   # quadrant 3
    ])

    for idx, seg in enumerate(spiral_segs):
        # Translate this segment of the spiral appropriately
        spiral_segs[idx] = (seg.transpose() + shift[quadrant]).transpose()
        # Compute next quadrant (wraps back to 0 after quadrant 3)
        quadrant = (quadrant + direction) % 4

    # Concatenate and return the transformed segments. Plotting and layout 
    # tools should take care of joining the lines between the ends of each
    # segment of the concatenated array of points.
    return np.concatenate(spiral_segs, axis=1)


def arithmetic_spiral_segments(coords):
    '''
    Given the cartesian coordiantes of an arithmetic spiral, this function 
    will divide the coordinates into groups such that the ends of each spiral
    segments will be tangent to either the x or y axes.

    Args:
        coords:         Cartesian coordinates defining an arithmetic spiral.
                        First column x coords. Second column y coords.
                        <np.ndarray of floats with shape (2, n)>

    Return:
        spiral_segs:    A list of 2-D numpy arrays, each of which represents
                        the coordinates of one segment.
                        <list of np.ndarrays>
    '''
    # Find indices of the points on the spiral that are parallel to either the
    # x or y axes.
    negy_inds = relex.argrelmin(coords[1])[0]
    posy_inds = relex.argrelmax(coords[1])[0]
    negx_inds = relex.argrelmin(coords[0])[0]
    posx_inds = relex.argrelmax(coords[0])[0]

    # Get the parallel points that will divide the spiral into the desired
    # segments, requested by the 'divison' argument.
    inds = np.concatenate((negy_inds, posy_inds, negx_inds, posx_inds))

    # Figure out how many segments to divide the spiral into.
    num_segs = inds.size - 1

    # Make sure there are enough parallel points for at least 1 full segment.
    if num_segs < 1:
        raise ValueError(
            "The sprial coordinates supplied did not contain a full segment. "
            + "Try supplying coordinates over a larger range, or dividing "
            + "into smaller segments.")

    # The indicies need to be sorted after the concatenation
    inds.sort()

    # Init a list of segments (can't be an np.ndarray since each segment 
    # will be a different length)
    spiral_segs = []

    for i in range(num_segs):
        start = inds[i]
        end = inds[i + 1] + 1
        spiral_segs.append(coords[:, start:end])

    return spiral_segs
    

def arithmetic_spiral_curve(turns, spacing, n_pts, start_turn=0, 
    start_angle=0, end_angle=0, radial_shift=0):
    '''
    Generates an array of Cartesian coordinates defining an arithmetic (aka
    Archimedean) spiral. The range of angles in degrees over which it is 
    plotted is given by 
    start = 360 * turns + start_angle
    end   = start + (360 * turns) + end_angle
    theta \in [start, end]

    Args:
        turns:          Number of full turns the spiral will make.
                        <int>

        spacing:        Distance between successive wrappings.
                        <float or int>

        n_pts:          Number of points defining the spiral.
                        <int>

        start_turn:     The turn of the spiral to start on. Must be a 
                        positive integer.
                        <int>

        start_angle:    Starting angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        end_angle:      End angle in degrees. Must have
                        0 <= start_angle < 360
                        <float or int>
                        (default: 0)

        radial_shift:   Shifts the radius uniformly. In the spiral
                        equation r = b * theta + a, a = radial_shift.
                        <float or int>
                        (default: 0)

    Return:
        An array of shape (2, n_pts) defining the spiral.
        First column x coords. Second column y coords.
        <2D np.ndarray>
    '''
    start_theta = ma.radians(360 * start_turn + start_angle)
    end_theta = start_theta + ma.radians(360 * turns + end_angle)
    theta = np.linspace(start_theta, end_theta, n_pts)

    b = spacing / (2 * ma.pi)
    r = radial_shift + (b * theta)

    x, y = polar_to_rect(r, theta)

    return np.stack((x, y))


def polar_to_rect(r, theta):
    '''
    Converts polar coordinates (r, theta) to cartesian cooridnates (x, y).
    theta should be supplied in radians.
    '''
    x = r * np.cos(theta)
    y = r * np.sin(theta)

    return x, y


def rect_to_polar(x, y):
    '''
    Converts Cartesian coordinates (x, y) to polar coordinates (r, theta).
    theta is returned in radians
    '''
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)

    return r, theta


def parabolic_taper(layout, start_width, end_width, length, 
    seg_length=seg_length, n_pts=None, origin='port0'):
    '''
    Generates a parabolic waveguide taper as a pya.DPolygon object.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        start_width:    Width of the taper at its left end. Must be smaller
                    `   than 'end_width'.
                        <float or int>

        end_width:      Width of the taper at its right end. Must be larger 
                        than 'start_width'.
                        <float or int>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>
                        (default: None)

        seg_length:     When rounding parabola, gives the distance between the
                        points defining it and sets n_pts appropriately. Does
                        this computation using the approximation of a graudal
                        taper (i.e., |start_width - end_width| << length).
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        n_pts:          Number of points defining each parabolic taper. Thus
                        The polygon with have a total of 2 * n_pts points.

        origin:         Indicates the location of the origin relative to 
                        the taper. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Left port (thin end)
                        'center'    Center relative to max device dimensions
                        'port1'     Right port (thick end)

                        <str>
                        (default: 'port0')

    Return:
        A polygon in the shape of a linear taper
        <pya.DPolygon object>
    '''
    if start_width > end_width:
        raise ValueError("Must have start_width < end_width")

    if n_pts is None:
        n_pts = int(round(length / seg_length))

    # TODO: replace with numpy arrays when people in the lab update KLayout
    # to the version with numpy built in


    # x-coordinates
    x_coords = np.linspace(0, length, n_pts)

    # Parameters for the parabola ax^2 + k defining the taper profile
    a = (end_width - start_width) / (2 * length**2)
    k = start_width / 2

    upper_profile =  a * x_coords**2 + k
    lower_profile = -upper_profile

    # Define points in the hull of the taper
    hull_upper = [pya.DPoint(x_coords[i], upper_profile[i]) 
        for i in range(n_pts)]
    hull_lower = [pya.DPoint(x_coords[i], lower_profile[i]) 
        for i in range(n_pts)]

    # instantiate the polygon
    taper = pya.DPolygon(hull_upper + hull_lower[::-1])

    # Shift the taper so that it has the desired coordinate origin.
    if origin == 'center':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length / 2, 0)))
    elif origin == 'port1':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length, 0)))
    elif origin == 'port0':
        pass
    else:
        raise ValueError("Expected arugment 'origin' to be one of 'port0', "
            + "'port1', or 'center'. instead got {}".format(origin))

    return taper


def linear_taper(layout, start_width, end_width, length, origin='port0'):
    '''
    Generates a linear waveguide taper as a pya.DPolygon object.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        start_width:    Width of the taper at its left end
                        <float or int>

        end_width:      Width of the taper at its right end
                        <float or int>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>
                        (default: None)

        origin:         Indicates the location of the origin relative to 
                        the taper. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Left port (thin end)
                        'center'    Center relative to max device dimensions
                        'port1'     Right port (thick end)

                        <str>
                        (default: 'port0')

    Return:
        A polygon in the shape of a linear taper
        <pya.DPolygon object>
    '''
    # Define points in the hull of the taper
    hull = [
        pya.DPoint(0,      -start_width / 2),
        pya.DPoint(0,       start_width / 2),
        pya.DPoint(length,  end_width / 2),
        pya.DPoint(length, -end_width / 2)
    ]

    # instantiate the polygon
    taper = pya.DPolygon(hull)

    # Shift the taper so that it has the desired coordinate origin.
    if origin == 'center':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length / 2, 0)))
    elif origin == 'port1':
        taper = taper.transformed(pya.DTrans(pya.DPoint(-length, 0)))
    elif origin == 'port0':
        pass
    else:
        raise ValueError("Expected argument 'origin' to be one of 'port0', "
            + "'port1', or 'center'. instead got {}".format(origin))

    return taper


def s_bend(layout, layer, length=None, height=None, bend_radius=None, 
    bend_angle=None, wg_width=wg_width, n_pts=None, seg_length=seg_length,
    origin='port0', trans=null_trans):
    '''
    Generates a path in the shape of an s-bend. Origin at the lower left port.
        
    The s-bend may be specified by any of the following parameter pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The bend is constrained to be composed entirely of rounded waveguide 
    except when the bend must be particularly steep. In other words, the only
    case in which a straight segment in the middle of the bend is allowed is
    when that straight segment is completely vertical. This is so that the 
    bend radius of the corners is maximized (and thus loss minimized).

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>      

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>
                        (default: None)

        bend_radius:    Radius of corner arcs. If supplied along with length,
                        2 * bend_radius >= length.
                        <float or int or None>
                        (default: None)

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>
                        (default: None)

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the  s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>
                        (default: None)

        wg_width:       Width of the path
                        <float or int>
                        (default: constants.wg_width == 0.5)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If None, this is computed based on the
                        value of 'seg_length'.
                        <int or None>
                        (default: None)

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts is None.
                        <float or int>
                        (default: constants.seg_length == 1.0)

        origin:         Indicates the location of the origin relative to 
                        the s-bend. Can be 'port0' or 'center'.

                        value       origin location
                        -----------------------------------------------------
                        'port0'     Lower left port
                        'center'    Center relative to overall dimensions

                        <str>
                        (default: 'port0')

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell that comprises the s-bend.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)


    # Raise an error if the bend has a radius less than the minimum (5 um)
    if bend_radius < min_bend_radius:
        raise ValueError("Computed a bend radius of"
                       + " {} um for the s-bend, ".format(bend_radius)
                       + "which is less than the minimum radius of"
                       + " {} um. Try".format(min_bend_radius)
                       + " making the bends less tight, or lower the value of"
                       + " chickpea.constants.min_bend_radius to stop showing"
                       + " this error.")

    if origin == 'center':
        center_to_origin = pya.DTrans(pya.DVector(-length / 2, -height / 2))
        trans = trans * center_to_origin
    elif origin == 'port0':
        pass
    else:
        raise ValueError(
            "Expected 'center' or 'port0' passed as argument 'origin'. "
            + "Instead got {}".format(origin))

    # KLayout will have trouble properly representing paths that were
    # generated with very small bend angles, since in this limit the two
    # points at the path verticies will be placed past the boundaries of the
    # layout, and we'd get asymmetries, wrap-arounds, etc.
    if not steep_bend and bend_angle < 1e-4:
        # This will approximate bend angles less that 1e-4 degrees as 0.
        return s_bend_double(layout, layer, wg_width=wg_width,
            bend_radius=bend_radius, n_pts=n_pts, seg_length=seg_length,
            trans=trans)

    if steep_bend:
        return s_bend_steep(layout, layer, height - 2 * bend_radius, 
            wg_width=wg_width, bend_radius=bend_radius, n_pts=n_pts, 
            seg_length=seg_length, trans=trans)
    else:
        return s_bend_shallow(layout, layer, length, bend_radius, 
            height, bend_angle, wg_width=wg_width, n_pts=n_pts, 
            seg_length=seg_length, trans=trans)


def s_bend_solve_params(length, bend_radius, height, bend_angle):
    '''
    Parses arguments to 's_bend' and calculates the unspecified paramters
    Also raises exceptions in cases with over/underspecification
    of parameters or if unsupported parameter pairs are supplied. Exactly
    two parameters should be supplied and they should be one of the pairs:
        (length, bend_radius),
        (height, bend_radius)
        (length, height),
        (bend_radius, bend_angle)

    The unspecified parameters should be left as None.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction. If supplied along with
                        bend_radius, length <= 2 * bend_raidus.
                        <float or int or None>

        bend_radius:    Radius of corner arcs. If supplied along with length,
                        2 * bend_radius >= length.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

    Return:
        steep_bend:     Indicates whether the s-bend is steep, meaning that 
                        the specified parameters must be met with an s-bend 
                        whose middle section goes completely vertical and 
                        whose corners form full 90 degree arcs.
                        <bool>

        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float>

        bend_radius:    Radius of corner arcs.
                        <float>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangent to the s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float>

    '''
    #
    # Check number of constraints
    #

    args = [length, bend_radius, height, bend_angle]
    unspecified = 0   # number of specified parameters
    for arg in args:
        if arg is None:
            unspecified += 1

    proper_constraints = "Exactly two parameters should be supplied "\
         + "and they should be one of the pairs: " + """
            (length, bend_radius),
            (height, bend_radius)
            (length, height),
            (bend_radius, bend_angle)
        The unspecified parameters should be left as None."""

    if unspecified < 2:
        raise ValueError("S-bend is over-constrained. " + proper_constraints)
    elif unspecified > 2:
        raise ValueError("S-bend is under-constrained. " + proper_constraints)

    #
    # Calculate the unspecified parameters
    #

    # Indicates whether the s-bend is steep, meaning that the specified 
    # parameters must be met with an s-bend whose middle section goes
    # completely vertical and whose corners form full 90 degree arcs.
    steep_bend = False  

    # Compute length and height from bend_angle and bend_radius
    if length is None and height is None:
        bend_angle = ma.radians(bend_angle)
        length, height = s_bend_solve_length_height(bend_angle, bend_radius)

    # Compute bend_radius and bend_angle from length and height
    elif bend_radius is None and bend_angle is None:
        bend_radius = length / 2
        # If the bend is taller than it is long, make it steep, unless the
        # steep bend has a bend radius smaller than the minimum in which
        # case we let shallow_s_bend make a bend that will double back on
        # itself, thus making the bend radius larger.
        steep_bend = height > length and bend_radius >= min_bend_radius
        if not steep_bend:
            bend_angle, bend_radius = s_bend_solve_angle_radius(length, height)

    # Compute height and bend_angle from length and bend_radius
    elif height is None and bend_angle is None:
        # If length > 2 * bend_radius, the s-bend must include a diagonal 
        # straight segment to satisify the length with such a small bend radius.
        # This is not supported for simplicity and because the bend radius
        # should generally be maximized anyway.
        if length > 2 * bend_radius:
            raise ValueError("bend_radius too small. Must have "
                           + "length <= 2 * bend_radius.")
        
        height, bend_angle = s_bend_solve_height_angle(length, bend_radius)

    # Compute length and bend_angle from height and bend_radius
    elif length is None and bend_angle is None:
        steep_bend = height > 2 * bend_radius
        if not steep_bend:
            length, bend_angle = s_bend_solve_length_angle(height, bend_radius)

    # The pair of parameters specified isn't supported, so raise an exception
    else:
        raise ValueError("That parameter pair is not supported " 
            + proper_constraints)

    return steep_bend, length, bend_radius, height, bend_angle


def s_bend_path_length(length=None, bend_radius=None, height=None, 
    bend_angle=None):
    '''
    Returns the path length of the s-bend generated by s_bend when supplied
    with the corresponding arguments.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>
    Return:
        The path length
        <float>
    '''
    steep_bend, length, bend_radius, height, bend_angle = \
        s_bend_solve_params(length, bend_radius, height, bend_angle)

    if steep_bend:
        bend_length = ma.pi * bend_radius
        straight_length = height - 2 * bend_radius
        return  bend_length + straight_length
    else:
        return 2 * bend_radius * (ma.pi - bend_angle)


def s_bend_solve_length_height(bend_angle, bend_radius):
    '''
    Returns the length and height of the s-bend with 'bend_angle' and 
    'bend_radius'.

    Args:
        bend_radius:    Radius of corner arcs.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

    Return: 
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>
    '''
    length = 2 * bend_radius * ma.sin(bend_angle)
    height = 2 * bend_radius * (1 + ma.cos(bend_angle))

    return length, height


def s_bend_solve_angle_radius(length, height):
    '''
    Returns the bend angle and bend radius of the s-bend with overall 
    dimensions of 'length' x 'height'. Only valid for length >= height. The
    parameters are generated with the constraint that there be no straight 
    segment in the middle of the s-bend (thus allowing the largest bend raidus
    possible for the specified dimensions).

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

    Return:
        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>


    '''
    # straight line distance separating s-bend ports, squared
    port_sep_squared = (height ** 2) + (length ** 2)

    bend_radius = port_sep_squared / (4 * height)

    argx = (height**2 - length**2) / port_sep_squared
    argy = (2 * height * length) / port_sep_squared
    bend_angle  = ma.atan2(argy, argx)

    return bend_angle, bend_radius


def s_bend_solve_height_angle(length, bend_radius):
    '''
    Calculates s-bend height and bend angle from length and bend_radius.
    I.e., calculates the parameters most convenient for constructing the 
    s-bend from the default user parameters for the s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

    Return:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>
    '''
    diameter = 2 * bend_radius
    a = ma.sqrt(diameter**2 - length**2)

    height = diameter - a
    bend_angle = ma.pi + ma.atan(-length / a)

    return height, bend_angle


def s_bend_solve_length_angle(height, bend_radius):
    '''
    Calculates s-bend length and bend angle from height and bend_radius.

    Args:
        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

    Return:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

    '''
    length = ma.sqrt(height * (4 * bend_radius - height))

    argy = length / bend_radius
    argx = (height / bend_radius) - 2

    bend_angle = ma.atan2(argy, argx)

    return length, bend_angle


def s_bend_shallow(layout, layer, length, bend_radius, height, bend_angle, 
    wg_width=wg_width, n_pts=None, seg_length=seg_length, trans=null_trans):
    '''
    Generates a shallow s-bend.

    Args:
        length:         Length of the s-bend. Also the distance between its
                        ports in the x-direction.
                        <float or int or None>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        bend_radius:    Radius of corner arcs.
                        <float or int or None>

        height:         Height of the s-bend. Also the distance between the 
                        centers of its ports in the y direction.
                        <float or int or None>

        bend_angle:     The angle in degrees between the x-axis and the line
                        tangentthe s-bend's inflexion point. It should be 
                        obtuse for a shallow s-bend and acute for a bend that 
                        will double back on itself.
                        <float or int or None>

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''

    x1 = bend_radius * ma.tan((ma.pi - bend_angle) / 2)
    dx = height * ma.tan(bend_angle - (ma.pi / 2))

    points = [
        pya.DPoint(0,       0),
        pya.DPoint(x1,      0),
        pya.DPoint(x1 + dx, height),
        pya.DPoint(length,  height)
    ]

    return path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length, trans=trans)


def s_bend_steep(layout, layer, length, wg_width=wg_width, bend_radius=bend_radius, 
	n_pts=None, seg_length=seg_length, trans=null_trans):
    '''
    Generates a path in the shape of an s-bend with 90 degree bends. A helper
    function for 's_bend' that handles the case height > length.
    Origin at the lower left port.

    Args:
        layout: 		Layout object for instantiation
                		<pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        length:         Length of straight segment in middle of the s-bend
                        <float>

        wg_width:  		Width of the path
                		<float>
                		(default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:			Number of points per full circle to use when rounding
        				corners. If None, this is computed based on the
        				value of 'seg_length'.
        				<int or None>
        				(default: None)

        seg_length:		When rounding corners, gives the distance between the
        				points defining the arc and sets n_pts appropriately.
        				Only used if n_pts is None.
        				<float>
        				(default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    points = [
    	pya.DPoint(0,               0                       ),
    	pya.DPoint(bend_radius,     0                       ),
    	pya.DPoint(bend_radius,     length + 2 * bend_radius),
    	pya.DPoint(2 * bend_radius, length + 2 * bend_radius)
	]

    return path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length, trans=trans)


def s_bend_double(layout, layer, wg_width=wg_width, bend_radius=bend_radius, 
    n_pts=None, seg_length=seg_length, trans=null_trans):
    '''
    Generates a path in the shape of an s-bend that doubles back on itself
    such that the horizontal distance between its ports is exactly zero.

    Args:
        layout:         Layout object for instantiation
                        <pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        wg_width:       Width of the path
                        <float>
                        (default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:          Number of points per full circle to use when rounding
                        corners. If None, this is computed based on the
                        value of 'seg_length'.
                        <int or None>
                        (default: None)

        seg_length:     When rounding corners, gives the distance between the
                        points defining the arc and sets n_pts appropriately.
                        Only used if n_pts is None.
                        <float>
                        (default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>
    '''
    points = [
        pya.DPoint( 0,               0              ),
        pya.DPoint( bend_radius,     0              ),
        pya.DPoint( bend_radius,     2 * bend_radius),
        pya.DPoint(-bend_radius,     2 * bend_radius),
        pya.DPoint(-bend_radius,     4 * bend_radius),
        pya.DPoint( 0,               4 * bend_radius)
    ]

    return path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius,
        n_pts=n_pts, seg_length=seg_length, trans=trans)


def path(layout, layer, points, wg_width=wg_width, bend_radius=bend_radius, n_pts=None, 
    seg_length=seg_length, trans=null_trans):
    '''
    Generates a rounded path PCell from the passed path.

    Args:
        layout: 		Layout object for instantiation
                		<pya.Layout object>

        layer:          The index of the layer to insert the path into (this
                        is the value returned from the layout.layer() method).
                        <int>

        points: 		Array of verticies in the path to be rounded.
               		 	<2 x n array-like of floats> 
                        OR 
                        <1D array-like of pya.DPoints>

        wg_width:  		Width of the path
                		<float>
                		(default: constants.wg_width == 0.5)

        bend_radius:    Radius of corner arcs
                        <float>
                        (default: constants.bend_radius == 10.0)

        n_pts:			Number of points per full circle to use when rounding
        				corners. If None, this is computed based on the
        				value of 'seg_length'.
        				<int or None>
        				(default: None)

        seg_length:		When rounding corners, gives the distance between the
        				points defining the arc and sets n_pts appropriately.
        				Only used if n_pts is None.
        				<float>
        				(default: constants.seg_length == 1.0)

        trans:          A transformation to apply upon instantiation of the
                        rounded path PCell.
                        <pya.DTrans object>
                        (default: transforms.null_trans)

    Return:
        The instantiated rounded path PCell.
        <pya.DCellInstArray object>

    '''
    # Compute number of points to keep the distance bewteen points on the
    # circle to seg_length
    if n_pts is None:
        n_pts = 2 * ma.pi * bend_radius / seg_length

    # If elements of 'points' aren't DPoints, try to convert them.
    if isinstance(points[0], pya.DPoint) == False:
        for point, idx in enumerate(points):
            points[idx] = pya.DPoint(p[0], p[1])

    path = pya.DPath(points, wg_width)

    basic_lib = pya.Library.library_by_name("Basic")
    pcell_dec = basic_lib.layout().pcell_declaration("ROUND_PATH")
    layer_name = layout.layer_infos()[layer]

    parameters = {
        "layer":   layer_name, 
        "radius":  bend_radius, 
        "path":    path, 
        "npoints": n_pts
    }

    pcell_idx = layout.add_pcell_variant(basic_lib, pcell_dec.id(), parameters)

    pcell = pya.DCellInstArray(pcell_idx, trans)

    return pcell


def array_to_DPoints(arr):
    '''
    Converts an ndarray of coordinates to a list of DPoints
    '''
    dpts = []

    for i in range(arr.shape[1]):
        dpts.append(pya.DPoint(arr[0, i], arr[1, i]))

    return dpts


def path_ports(path):
    '''
    Computes the locations and direction of the ports of a path
    '''
    dpts = list(path.each_point())

    first_segment = dpts[0] - dpts[1]
    port0_angle = ma.atan2(first_segment.y, first_segment.x)
    port0_loc = dpts[0]

    last_segment = dpts[-1] - dpts[-2]
    port1_angle = ma.atan2(last_segment.y, last_segment.x)
    port1_loc = dpts[-1]

    return [[port0_loc, port0_angle], [port1_loc, port1_angle]]


def within_angle(actual, nominal, tolerance):
    '''
    Checks whether an angle 'acutal' is within 'tolerance' of a nominal angle
    'nominal', accounting for modularity. Arguments must be in degrees.
    '''
    if actual < 0:
        actual += 360
    lower_bound = (nominal - tolerance) % 360
    if lower_bound < 0:
        lower_bound += 360
    upper_bound = ((nominal + tolerance) % 360) - lower_bound
    if upper_bound < 0:
        upper_bound += 360
    actual = (actual % 360) - lower_bound
    if actual < 0:
        actual += 360

    return actual <= upper_bound
