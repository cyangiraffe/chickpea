# This script sets up FDTD for a simulation of a directional coupler 
# from a GDS file of the device  generated by the function 
# 'dir_coupler' in the package 'chickpea'.

# Revision History:
#   05 Jul 2019 Julian Sanders  Initial Revision

deleteall;

#
# User arguments to script
#

# path to GDS of the 3dB coupler to be tested
coupler_path = "{gds_path}";

bend_radius = {bend_radius}e-6;    # corner bend radius
sep = {sep}e-6;          # distance b/w coupling waveguides
c_length = {length}e-6;   # coupling length
wg_width = {wg_width}e-6;     # waveguide width
wg_height = 220e-9;      # waveguide height

# Compute overall dimensions of the coupler
full_length = 4 * bend_radius + c_length;
full_height = 4 * bend_radius + 2 * wg_width + sep;
max_y = full_height - (wg_width / 2); # max y coord device occupies
min_y = -wg_width / 2;                 # min y coord device occupies

top_port_y = max_y - (wg_width / 2);
bottom_port_y = 0;
left_port_x = 0;
right_port_x = full_length;

extra_length = 5e-6; # length of extra wg extending from output
                     # to facilitate coupling length sweeps

path_length = c_length + (2 * bend_radius * 3.1415) + extra_length;
grp_vel = 5.5e7;        # pessemistic group velocity estimate (m/s)
sim_time = path_length / grp_vel;

# Oxide substrate
sub_buff = 2e-6; # extend oxide this far past coupler dimensions
addrect;
set('name', 'substrate');
set("material","SiO2 (Glass) - Palik");
set('x min', -sub_buff);
set('x max', full_length + sub_buff + extra_length);
set('y min', min_y - sub_buff);
set('y max', max_y + sub_buff);
set('z min', -3e-6);
set('z max', 3e-6);
set('alpha', 0.2);

#
# Import waveguides
#

# Create a structure group encompassing all the
# waveguide structure groups and their variables
addstructuregroup;
set('name', 'waveguides');
adduserprop('coupling_length', 2, c_length);

# import each cell of the coupler as a separate
# structure group.
coupler_cells = cell(6);
coupler_cells{{1}} = 'input1';
coupler_cells{{2}} = 'straight1';
coupler_cells{{3}} = 'output1';
coupler_cells{{4}} = 'input2';
coupler_cells{{5}} = 'straight2';
coupler_cells{{6}} = 'output2';

for (i = 1; i <= 6; i = i + 1) {{
    gdsimport(coupler_path, coupler_cells{{i}}, 1);
    set("material","Si (Silicon) - Palik");
    set('name', coupler_cells{{i}});
    set('z', 0);
    set('z span', wg_height);
    addtogroup('waveguides');
}}

# Add extra waveguides at the output that we can place monitors at 
# the end of. This way, length sweeps can be done without changing 
# monitor's position, which can cause data concatenation errors.
addrect;
set('name', 'bottom_extra');
set("material", "Si (Silicon) - Palik");
addtogroup('waveguides');
set('use relative coordinates', 0);
set('x min', right_port_x);
set('x max', right_port_x + extra_length);
set('y', bottom_port_y);
set('y span', wg_width);
set('z', 0);
set('z span', wg_height);

addrect;
set('name', 'top_extra');
set("material", "Si (Silicon) - Palik");
addtogroup('waveguides');
set('use relative coordinates', 0);
set('x min', right_port_x);
set('x max', right_port_x + extra_length);
set('y', top_port_y);
set('y span', wg_width);
set('z', 0);
set('z span', wg_height);


# Generate a setup script for the waveguide group so that
# the coupling length can be controlled by a single user
# variable in the 'waveguides' group.
wg_script = "orig_length = " + num2str(c_length) + "; # coupling length from GDS import\n";
wg_script = wg_script + "full_length = (4 * " + num2str(bend_radius) + ") + %coupling_length%; # full device length\n";
wg_script = wg_script + "# Set child group user variables according to desiered length\n";
wg_script = wg_script + "select('straight1');\n";
wg_script = wg_script + "set('length', %coupling_length%);\n";
wg_script = wg_script + "select('straight2');";
wg_script = wg_script + "set('length', %coupling_length%);\n";
wg_script = wg_script + "select('output1');\n";
wg_script = wg_script + "set('deltaL', %coupling_length% - orig_length);\n";
wg_script = wg_script + "select('output2');\n";
wg_script = wg_script + "set('deltaL', %coupling_length% - orig_length);\n";
wg_script = wg_script + "select('bottom_extra');\n";
wg_script = wg_script + "set('x min', full_length);\n";
wg_script = wg_script + "select('top_extra');\n";
wg_script = wg_script + "set('x min', full_length);\n";

select('waveguides');
set('script', wg_script);


#
# Set up simulation, ports, and monitors
#


# Configure a FDTD simulation region
addfdtd;
sim_buff_xy = sub_buff / 4; # extend fdtd this far past coupler x-y limits
sim_buff_z = 1.5e-6; # fdtd spans this much further in z than waveguides do.
set('x min', 0);
set('x max', full_length + extra_length);
set('y min', min_y - sim_buff_xy);
set('y max', max_y + sim_buff_xy);
set('z', 0);
set('z span', wg_height + sim_buff_z);
set('simulation time', sim_time);

# Configure ports for S-param extraction

port_coords = [ # x, y coordinates of each port
    left_port_x,  bottom_port_y;
    left_port_x,  top_port_y;
    right_port_x + extra_length, bottom_port_y;
    right_port_x + extra_length, top_port_y
];

port_names = cell(4);
port_names{{1}} = 'input_port1';
port_names{{2}} = 'input_port2';
port_names{{3}} = 'output_port1';
port_names{{4}} = 'output_port2';


for (i = 1; i <= 4; i = i + 1) {{
    addport;
    set('name', port_names{{i}});
    set('x', port_coords(i, 1));
    set('y', port_coords(i, 2));
    set('z', 0);
    set('y span', 3 * wg_width);
    set('z span', 3 * wg_height);
    seteigensolver('bent waveguide', true);
    seteigensolver('bend radius', bend_radius);
}}

select('FDTD::ports::output_port1');
set('direction', 'backward');

select('FDTD::ports::output_port2');
set('direction', 'backward');
set('bend orientation', 180);

select('FDTD::ports::input_port1');
set('bend orientation', 180);


# Global source properties
setglobalsource('center wavelength', 1550e-9);
setglobalsource('wavelength span',  10e-9);

# Top view monitor
addpower;
set('name', "top");
set('monitor type', '2D z-normal');
set('x min', 0);    # same geometry as FDTD region.
set('x max', full_length + extra_length);
set('y min', min_y - sim_buff_xy);
set('y max', max_y + sim_buff_xy);


# input/ouput monitor spans this much bigger than waveguide dimensions
monitor_buff = 0.25e-6;
out_from_edge = 100e-9; # ouput monitors this far from FDTD edge


# Monitor at input1 (just in front of the source)
addpower;
set('name', 'input_power');
set('monitor type', '2D x-normal');
set('x', 0.2e-6);
set('y', 0);
set('z', 0);
set('y span', wg_width + monitor_buff);
set('z span', wg_height + monitor_buff);

# Monitor at output1 (bottom output)
addpower;
set('name', 'output_power1');
set('monitor type', '2D x-normal');
set('x', full_length - out_from_edge + extra_length);
set('y', 0);
set('z', 0);
set('y span', wg_width + monitor_buff);
set('z span', wg_height + monitor_buff);

# Monitor at output2 (top output)
addpower;
set('name', 'output_power2');
set('monitor type', '2D x-normal');
set('x', full_length - out_from_edge + extra_length);
set('y', top_port_y);
set('z', 0);
set('y span', wg_width + monitor_buff);
set('z span', wg_height + monitor_buff);

#
# Parametrize structure groups for sweeps
#

straights = cell(2);
straights{{1}} = 'straight1';
straights{{2}} = 'straight2';

for (i = 1; i <= 2; i = i + 1) {{
select('waveguides::' + straights{{i}});
adduserprop("length", 2, c_length);

set('script', "
selectall;
set('material', %material%);
if (%material% == '<Object defined dielectric>') {{
    set('index', %index%);
}}
set('z span', %z span%);
set('z', 0);

selectall;
vtx = get('vertices');
left_x = vtx(1, 1);
vtx(3, 1) = %length% + left_x;
vtx(4, 1) = %length% + left_x;
set('vertices', vtx);
");
}}

# S-bends at the outputs get a user variable that shifts their
# position from the position originally assigned in this script.
# This accomodates the added length of the straight segments.
outs = cell(2);
outs{{1}} = 'output1';
outs{{2}} = 'output2';

for (i = 1; i <= 2; i = i + 1) {{
select('waveguides::' + outs{{i}});
adduserprop("deltaL", 2, 0);

set('script', "
selectall;
set('material', %material%);
if (%material% == '<Object defined dielectric>') {{
    set('index', %index%);
}}
set('z span', %z span%);
set('z', 0);

selectall;
set('x', %deltaL%);
");
}}


# Add a unit cube for setting aspect ratio
addrect;
set('name', 'zoom');
set('x', -4e-6);
set('y', 0);
set('z', 0);
set('x span', 1e-6);
set('y span', 1e-6);
set('z span', 1e-6);
set('enabled', 0);
